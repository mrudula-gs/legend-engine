package com.gs.alloy.lakehouse.runtime.model.grammar.serializer;

import com.gs.alloy.lakehouse.ingest.api.accessor.protocol.IngestRelationAccessor;
import com.gs.alloy.lakehouse.protocol.pure.v1.model.packageableElement.mapping.IngestRelationColumn;
import com.gs.alloy.lakehouse.protocol.pure.v1.model.packageableElement.mapping.LakehouseClassMapping;
import com.gs.alloy.lakehouse.protocol.pure.v1.model.packageableElement.mapping.LakehouseDynaFunc;
import com.gs.alloy.lakehouse.protocol.pure.v1.model.packageableElement.mapping.LakehouseLiteral;
import com.gs.alloy.lakehouse.protocol.pure.v1.model.packageableElement.mapping.LakehousePropertyMapping;
import com.gs.alloy.lakehouse.protocol.pure.v1.model.packageableElement.mapping.LakehouseRelationalOperationElement;
import com.gs.alloy.lakehouse.protocol.pure.v1.model.packageableElement.runtime.LakehouseRuntime;
import com.gs.alloy.lakehouse.runtime.model.grammar.parser.LakehouseRuntimeParserExtension;
import org.eclipse.collections.api.block.function.Function2;
import org.eclipse.collections.api.block.function.Function3;
import org.eclipse.collections.api.factory.Lists;
import org.eclipse.collections.api.list.MutableList;
import org.eclipse.collections.impl.utility.Iterate;
import org.eclipse.collections.impl.utility.LazyIterate;
import org.eclipse.collections.impl.utility.ListIterate;
import org.finos.legend.engine.language.pure.grammar.to.HelperDomainGrammarComposer;
import org.finos.legend.engine.language.pure.grammar.to.PureGrammarComposerContext;
import org.finos.legend.engine.language.pure.grammar.to.PureGrammarComposerUtility;
import org.finos.legend.engine.language.pure.grammar.to.extension.PureGrammarComposerExtension;
import org.finos.legend.engine.protocol.pure.v1.model.packageableElement.mapping.ClassMapping;
import org.finos.legend.engine.protocol.pure.v1.model.packageableElement.mapping.PropertyMapping;
import org.finos.legend.engine.protocol.pure.v1.model.packageableElement.runtime.PackageableRuntime;

import java.util.Collections;
import java.util.List;

import static org.finos.legend.engine.language.pure.grammar.to.PureGrammarComposerUtility.appendTabString;
import static org.finos.legend.engine.language.pure.grammar.to.PureGrammarComposerUtility.getTabString;

public class LakehouseRuntimeGrammarComposerExtension implements PureGrammarComposerExtension
{
    @Override
    public MutableList<String> group()
    {
        return Lists.mutable.with("PackageableElement", "LakehouseRuntime");
    }

    @Override
    public List<Function3<List<PackageableElement>, PureGrammarComposerContext, List<String>, PureFreeSectionGrammarComposerResult>> getExtraFreeSectionComposers()
    {
        return Collections.singletonList((elements, context, composedSections) ->
        {
            MutableList<PackageableElement> composableElements = Iterate.select(elements, e -> (e instanceof PackageableRuntime && ((PackageableRuntime) e).runtimeValue instanceof LakehouseRuntime), Lists.mutable.empty());
            return composableElements.isEmpty()
                    ? null
                    : new PureFreeSectionGrammarComposerResult(composableElements.asLazy().collect(element -> renderLakehouseRuntime(((PackageableRuntime) element), context)).makeString("###" + LakehouseRuntimeParserExtension.NAME + "\n", "\n\n", ""), composableElements);
        });
    }

    private static String renderLakehouseRuntime(PackageableRuntime lakeRuntime, PureGrammarComposerContext context)
    {
        String runtimeType = "LakehouseRuntime ";
        return runtimeType + PureGrammarComposerUtility.convertPath(lakeRuntime.getPath()) + "\n" +
                "{" +
                     renderRuntimeValue((LakehouseRuntime) lakeRuntime.runtimeValue, 1) +
                "\n}";
    }

    private static String renderRuntimeValue(LakehouseRuntime runtimeValue, int baseIndentation)
    {
        StringBuilder builder = new StringBuilder();
        if (runtimeValue.environment != null && runtimeValue.warehouse != null)
        {
            appendTabString(builder.append("\n"), baseIndentation).append("environment: '").append(runtimeValue.environment).append("';");
            appendTabString(builder.append("\n"), baseIndentation).append("warehouse: '").append(runtimeValue.warehouse).append("';");
        }
        else if (runtimeValue.environment == null && runtimeValue.warehouse == null && runtimeValue.connectionPointer != null)
        {
            appendTabString(builder.append("\n"), baseIndentation).append("connection: ").append(PureGrammarComposerUtility.convertPath(runtimeValue.connectionPointer.connection)).append(";");
        }
        return builder.toString();
    }

    @Override
    public List<Function3<List<PackageableElement>, PureGrammarComposerContext, String, String>> getExtraSectionComposers()
    {
        return Lists.fixedSize.with((elements, context, sectionName) ->
        {
            if (!LakehouseRuntimeParserExtension.NAME.equals(sectionName))
            {
                return null;
            }
            return ListIterate.collect(elements, element ->
            {
                if (element instanceof PackageableRuntime)
                {
                    return renderLakehouseRuntime((PackageableRuntime) element, context);
                }
                return "/* Can't transform element '" + element.getPath() + "' in this section */";
            }).makeString("\n\n");
        });
    }

    @Override
    public List<Function2<ClassMapping, PureGrammarComposerContext, String>> getExtraClassMappingComposers()
    {
        return Lists.mutable.with((classMapping, context) ->
        {
            if (classMapping instanceof LakehouseClassMapping)
            {
                LakehouseClassMapping lakehouseClassMapping = (LakehouseClassMapping) classMapping;
                StringBuilder builder = new StringBuilder();
                builder.append(": ").append(LakehouseRuntimeParserExtension.LAKEHOUSE_MAPPING_ELEMENT_TYPE).append("\n");
                builder.append(getTabString()).append("{\n");
                String mapping = renderLakehouseClassMapping(lakehouseClassMapping);
                builder.append(mapping);
                builder.append(getTabString()).append("}");
                return builder.toString();
            }
            return null;
        });
    }

    private String renderLakehouseClassMapping(LakehouseClassMapping lakehouseClassMapping)
    {
        StringBuilder builder = new StringBuilder();
        if (lakehouseClassMapping.ingestPtr != null)
        {
            IngestRelationAccessor tmp = lakehouseClassMapping.ingestPtr;
            appendTabString(builder, 2).append("~ingestSource ");
            builder.append("[").append(tmp.path.get(0)).append("]");
            builder.append(tmp.path.get(1));
            builder.append("\n");
        }
        if (!lakehouseClassMapping.propertyMappings.isEmpty())
        {
            builder.append(LazyIterate.collect(lakehouseClassMapping.propertyMappings, propertyMapping ->
                    renderRelationalPropertyMapping(propertyMapping, false)).makeString(",\n"));
            builder.append("\n");
        }
        return builder.toString();
    }

    private static boolean checkNullOrEmpty(String string)
    {
        return string == null || string.isEmpty();
    }

    private static String renderRelationalPropertyMapping(PropertyMapping relationalPropertyMapping, Boolean renderSourceId)
    {
        LakehousePropertyMapping lakehousePropertyMapping = (LakehousePropertyMapping) relationalPropertyMapping;
        String propertyString = getTabString(2) + (relationalPropertyMapping.localMappingProperty != null
                ? ("+" + PureGrammarComposerUtility.convertIdentifier(relationalPropertyMapping.property.property) + ": " +
                relationalPropertyMapping.localMappingProperty.type + "[" +
                HelperDomainGrammarComposer.renderMultiplicity(relationalPropertyMapping.localMappingProperty.multiplicity) + "]")
                : PureGrammarComposerUtility.convertIdentifier(relationalPropertyMapping.property.property) +
                (checkNullOrEmpty(relationalPropertyMapping.target) ? "" : "[" + (renderSourceId ?
                        (checkNullOrEmpty(relationalPropertyMapping.source) ? "" : (relationalPropertyMapping.source + ",")) : "") +
                        relationalPropertyMapping.target + "]")
        ) + ": ";
        return propertyString + renderRelationalOperationElement(lakehousePropertyMapping.relationalOperation);
    }

    private static String renderRelationalOperationElement(LakehouseRelationalOperationElement operation)
    {
        if (operation instanceof LakehouseDynaFunc)
        {
            LakehouseDynaFunc func = (LakehouseDynaFunc) operation;
            StringBuilder builder = new StringBuilder();
            builder.append(PureGrammarComposerUtility.convertIdentifier(func.funcName));
            builder.append("(");
            builder.append(ListIterate.collect(func.parameters, LakehouseRuntimeGrammarComposerExtension::renderRelationalOperationElement).makeString(", "));
            builder.append(")");
            return builder.toString();
        }
        else if (operation instanceof IngestRelationColumn)
        {
            IngestRelationColumn column = (IngestRelationColumn) operation;
            return "[" + column.ingestAccessor.path.get(0) + "]" + column.ingestAccessor.path.get(1) + "." + column.column;
        }
        else if (operation instanceof LakehouseLiteral)
        {
            LakehouseLiteral literal = (LakehouseLiteral) operation;
            if (literal.value instanceof String)
            {
                return PureGrammarComposerUtility.convertString((String) literal.value, true);
            }
            return literal.value.toString();
        }
        throw new IllegalStateException("Unsupported operation type: " + operation.getClass().getSimpleName());
    }
}
