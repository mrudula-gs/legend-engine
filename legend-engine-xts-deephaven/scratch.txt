parser grammar LakehouseMappingParserGrammar;

import RelationalParserGrammar;

options
{
    tokenVocab = LakehouseMappingLexerGrammar;
}

// -------------------------------------- IDENTIFIER --------------------------------------

unquotedIdentifier:                         VALID_STRING
                                            | ALL | LET | ALL_VERSIONS | ALL_VERSIONS_IN_RANGE
                                            | TO_BYTES_FUNCTION
                                            | INGEST_SOURCE_CMD | ACCESS_POINT_SOURCE_CMD
;

identifier:                                 unquotedIdentifier | STRING
;

// -------------------------------------- LAKEHOUSE MAPPING DEFINITION --------------------------------------

lakehouseClassMapping:                      (ingestSrc | accessPointSrc)
                                                (propertyMapping (COMMA propertyMapping)*)?
                                            EOF
;
ingestSrc:                                  INGEST_SOURCE_CMD databasePointer qualifiedName
;
accessPointSrc:                             ACCESS_POINT_SOURCE_CMD databasePointer qualifiedName
;
propertyMapping:                            qualifiedName STAR? COLON operation
;
mappingScopeInfo:                           unquotedIdentifier
;
// -------------------------------------- BUILDING BLOCK --------------------------------------

 scopeInfo:                                  relationalIdentifier (DOT relationalIdentifier)?
 ;
 databasePointer:                            BRACKET_OPEN qualifiedName BRACKET_CLOSE
 ;
 relationalIdentifier:                       unquotedIdentifier | QUOTED_STRING
 ;



public class LakehouseRuntimeParserExtension implements PureGrammarParserExtension
{
    public static final String NAME = "LakehouseRuntime";
    public static final String LAKEHOUSE_MAPPING_ELEMENT_TYPE = "Lakehouse";

    @Override
    public MutableList<String> group()
    {
        return Lists.mutable.with("PackageableElement", "LakehouseRuntime");
    }

    @Override
    public Iterable<? extends SectionParser> getExtraSectionParsers()
    {
        return Lists.fixedSize.of(SectionParser.newParser(NAME, this::parseSection));
    }

    private Section parseSection(SectionSourceCode sectionSourceCode, Consumer<PackageableElement> elementConsumer, PureGrammarParserContext context)
    {
        SourceCodeParserInfo parserInfo = getRuntimeSectionParserInfo(sectionSourceCode);
        DefaultCodeSection section = new DefaultCodeSection();
        section.parserName = sectionSourceCode.sectionType;
        section.sourceInformation = parserInfo.sourceInformation;
        LakehouseRuntimeParseTreeWalker walker = new LakehouseRuntimeParseTreeWalker(parserInfo.walkerSourceInformation, elementConsumer, section);
        walker.visit((LakehouseRuntimeParserGrammar.DefinitionContext) parserInfo.rootContext);
        return section;
    }

    private SourceCodeParserInfo getRuntimeSectionParserInfo(SectionSourceCode sectionSourceCode)
    {
        CharStream input = CharStreams.fromString(sectionSourceCode.code);
        ParserErrorListener errorListener = new ParserErrorListener(sectionSourceCode.walkerSourceInformation, LakehouseRuntimeLexerGrammar.VOCABULARY);
        LakehouseRuntimeLexerGrammar lexer = new LakehouseRuntimeLexerGrammar(input);
        lexer.removeErrorListeners();
        lexer.addErrorListener(errorListener);
        LakehouseRuntimeParserGrammar parser = new LakehouseRuntimeParserGrammar(new CommonTokenStream(lexer));
        parser.removeErrorListeners();
        parser.addErrorListener(errorListener);
        return new SourceCodeParserInfo(sectionSourceCode.code, input, sectionSourceCode.sourceInformation, sectionSourceCode.walkerSourceInformation, lexer, parser, parser.definition());
    }

    public static SourceCodeParserInfo getMappingSectionParserInfo(MappingElementSourceCode mappingElementSourceCode)
    {
        CharStream input = CharStreams.fromString(mappingElementSourceCode.code);
        ParserErrorListener errorListener = new ParserErrorListener(mappingElementSourceCode.mappingParseTreeWalkerSourceInformation);
        LakehouseMappingLexerGrammar lexer = new LakehouseMappingLexerGrammar(input);
        lexer.removeErrorListeners();
        lexer.addErrorListener(errorListener);
        LakehouseMappingParserGrammar parser = new LakehouseMappingParserGrammar(new CommonTokenStream(lexer));
        parser.removeErrorListeners();
        parser.addErrorListener(errorListener);
        LakehouseMappingParserGrammar.LakehouseClassMappingContext classMappingCtx = parser.lakehouseClassMapping();
        return new SourceCodeParserInfo(mappingElementSourceCode.code,
                input,
                mappingElementSourceCode.mappingParseTreeWalkerSourceInformation.getSourceInformation(mappingElementSourceCode.mappingElementParserRuleContext),
                mappingElementSourceCode.mappingElementParseTreeWalkerSourceInformation,
                lexer,
                parser,
                classMappingCtx);
    }

    @Override
    public Iterable<? extends MappingElementParser> getExtraMappingElementParsers()
    {
        return Collections.singletonList(MappingElementParser.newParser(LAKEHOUSE_MAPPING_ELEMENT_TYPE,
                        (mappingElementSourceCode, parserContext) ->
                        {
                            MappingParserGrammar.MappingElementContext ctx = mappingElementSourceCode.mappingElementParserRuleContext;
                            SourceCodeParserInfo parserInfo = getMappingSectionParserInfo(mappingElementSourceCode);
                            LakehouseClassMappingParseTreeWalker walker = new LakehouseClassMappingParseTreeWalker(parserInfo.walkerSourceInformation,
                                    parserInfo.input, parserContext);

                            LakehouseClassMapping lakehouseClassMapping = new LakehouseClassMapping();
                            lakehouseClassMapping._class = PureGrammarParserUtility.fromQualifiedName(ctx.qualifiedName().packagePath() == null ? Collections.emptyList() : ctx.qualifiedName().packagePath().identifier(), ctx.qualifiedName().identifier());
                            lakehouseClassMapping.root = ctx.STAR() != null;
                            lakehouseClassMapping.id = ctx.mappingElementId() != null ? ctx.mappingElementId().getText() : null; //anumam
                            walker.visitLakehouseClassMapping((LakehouseMappingParserGrammar.LakehouseClassMappingContext) parserInfo.rootContext, ctx, lakehouseClassMapping);
                            return lakehouseClassMapping;
                        })
                );
    }
}





package com.gs.alloy.lakehouse.runtime.model.grammar.parser;

import com.gs.alloy.lakehouse.ingest.api.accessor.protocol.IngestRelationAccessor;
import com.gs.alloy.lakehouse.protocol.pure.v1.model.packageableElement.mapping.IngestRelationColumn;
import com.gs.alloy.lakehouse.protocol.pure.v1.model.packageableElement.mapping.LakehouseClassMapping;
import com.gs.alloy.lakehouse.protocol.pure.v1.model.packageableElement.mapping.LakehousePropertyMapping;
import com.gs.alloy.lakehouse.runtime.grammar.antlr4.LakehouseMappingParserGrammar;
import org.antlr.v4.runtime.CharStream;
import org.eclipse.collections.api.factory.Lists;
import org.eclipse.collections.impl.utility.ListIterate;
import org.finos.legend.engine.language.pure.grammar.from.ParseTreeWalkerSourceInformation;
import org.finos.legend.engine.language.pure.grammar.from.PureGrammarParserContext;
import org.finos.legend.engine.language.pure.grammar.from.PureGrammarParserUtility;
import org.finos.legend.engine.language.pure.grammar.from.antlr4.mapping.MappingParserGrammar;
import org.finos.legend.engine.protocol.pure.v1.model.context.EngineErrorType;
import org.finos.legend.engine.protocol.pure.v1.model.packageableElement.mapping.PropertyPointer;
import org.finos.legend.engine.protocol.pure.v1.model.packageableElement.store.relational.model.operation.DynaFunc;
import org.finos.legend.engine.protocol.pure.v1.model.packageableElement.store.relational.model.operation.Literal;
import org.finos.legend.engine.protocol.pure.v1.model.packageableElement.store.relational.model.operation.RelationalOperationElement;
import org.finos.legend.engine.shared.core.operational.errorManagement.EngineException;

import java.util.ArrayList;
import java.util.Collections;

public class LakehouseClassMappingParseTreeWalker
{
    private final CharStream input;
    private final ParseTreeWalkerSourceInformation walkerSourceInformation;
    private final PureGrammarParserContext parserContext;

    public LakehouseClassMappingParseTreeWalker(ParseTreeWalkerSourceInformation walkerSourceInformation, CharStream input, PureGrammarParserContext parserContext)
    {
        this.input = input;
        this.walkerSourceInformation = walkerSourceInformation;
        this.parserContext = parserContext;
    }

    private String visitDatabasePointer(LakehouseMappingParserGrammar.DatabasePointerContext ctx)
    {
        return ctx != null ? PureGrammarParserUtility.fromQualifiedName(ctx.qualifiedName().packagePath() == null ? Collections.emptyList() : ctx.qualifiedName().packagePath().identifier(), ctx.qualifiedName().identifier()) : null;
    }

    private String visitMappingScopeInfo(LakehouseMappingParserGrammar.MappingScopeInfoContext ctx)
    {
        return ctx != null ? PureGrammarParserUtility.fromIdentifier(ctx.unquotedIdentifier()) : null;
    }

    public void visitLakehouseClassMapping(LakehouseMappingParserGrammar.LakehouseClassMappingContext ctx, MappingParserGrammar.MappingElementContext classMappingContext, LakehouseClassMapping lakehouseClassMapping)
    {
        if (ctx.ingestSrc() != null)
        {
            IngestRelationAccessor tmp = new IngestRelationAccessor();
            tmp.path = Lists.mutable.with(visitDatabasePointer(ctx.ingestSrc().databasePointer()), ctx.ingestSrc().qualifiedName().getText());
            tmp.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx.ingestSrc());
            lakehouseClassMapping.ingestPtr = tmp;
        }
        // property mappings (optional)
        lakehouseClassMapping.propertyMappings = ListIterate.collect(ctx.propertyMapping(), propertyMappingContext -> visitPropertyMapping(propertyMappingContext, classMappingContext, lakehouseClassMapping));
    }

//    private LakehousePropertyMapping visitPropertyMapping(LakehouseMappingParserGrammar.PropertyMappingContext ctx, MappingParserGrammar.MappingElementContext classMappingContext, LakehouseClassMapping lakehouseClassMapping)
//    {
//        LakehousePropertyMapping propertyMapping = new LakehousePropertyMapping();
//        propertyMapping.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
//        PropertyPointer propertyPointer = new PropertyPointer();
//        propertyPointer.property = PureGrammarParserUtility.fromIdentifier(ctx.qualifiedName(0));
//        propertyPointer._class = lakehouseClassMapping._class;
//        propertyPointer.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
//        propertyMapping.property = propertyPointer;
//        propertyMapping.source = lakehouseClassMapping.id;
//        propertyMapping.relationalColumn = new IngestRelationColumn();
//        propertyMapping.relationalColumn.ingestAccessor = lakehouseClassMapping.ingestPtr;
//        propertyMapping.relationalColumn.Column = PureGrammarParserUtility.fromIdentifier(ctx.qualifiedName(2));
//        propertyMapping.property.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
//        return propertyMapping;
//    }

    private LakehousePropertyMapping visitPropertyMapping(LakehouseMappingParserGrammar.PropertyMappingContext ctx, MappingParserGrammar.MappingElementContext classMappingContext, LakehouseClassMapping lakehouseClassMapping)
    {
        LakehousePropertyMapping propertyMapping = new LakehousePropertyMapping();
        propertyMapping.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
        PropertyPointer propertyPointer = new PropertyPointer();
        propertyPointer.property = PureGrammarParserUtility.fromIdentifier(ctx.qualifiedName());
        propertyPointer._class = lakehouseClassMapping._class;
        propertyPointer.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
        propertyMapping.property = propertyPointer;
        propertyMapping.source = lakehouseClassMapping.id;

        // Parse the operation
        propertyMapping.relationalOperation = visitOperation(ctx.operation(), lakehouseClassMapping.ingestPtr);

        return propertyMapping;
    }

    private RelationalOperationElement visitOperation(LakehouseMappingParserGrammar.OperationContext ctx, IngestRelationAccessor ingestPtr)
    {
        if (ctx.booleanOperation() != null)
        {
            return visitBooleanOperation(ctx.booleanOperation(), ingestPtr);
        }
        else if (ctx.joinOperation() != null)
        {
            throw new EngineException("Join operations are not yet supported in Lakehouse mappings", this.walkerSourceInformation.getSourceInformation(ctx), EngineErrorType.PARSER);
        }
        throw new EngineException("Unsupported syntax", this.walkerSourceInformation.getSourceInformation(ctx), EngineErrorType.PARSER);
    }

    private RelationalOperationElement visitBooleanOperation(LakehouseMappingParserGrammar.BooleanOperationContext ctx, IngestRelationAccessor ingestPtr)
    {
        RelationalOperationElement operationElement = visitAtomicOperation(ctx.atomicOperation(), ingestPtr);
        if (ctx.booleanOperationRight() != null)
        {
            DynaFunc operation = new DynaFunc();
            operation.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
            operation.funcName = ctx.booleanOperationRight().booleanOperator().AND() != null ? "and" : "or";
            operation.parameters = new ArrayList<>();
            operation.parameters.add(operationElement);
            RelationalOperationElement right = visitOperation(ctx.booleanOperationRight().operation(), ingestPtr);
            operation.parameters.add(right);
            return operation;
        }
        return operationElement;
    }

    private RelationalOperationElement visitAtomicOperation(LakehouseMappingParserGrammar.AtomicOperationContext ctx, IngestRelationAccessor ingestPtr)
    {
        RelationalOperationElement operationElement = null;
        if (ctx.groupOperation() != null)
        {
            DynaFunc operation = new DynaFunc();
            operation.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
            operation.funcName = "group";
            operation.parameters = new ArrayList<>();
            operation.parameters.add(visitOperation(ctx.groupOperation().operation(), ingestPtr));
            operationElement = operation;
        }
        else if (ctx.functionOperation() != null)
        {
            DynaFunc operation = new DynaFunc();
            operation.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
            operation.funcName = PureGrammarParserUtility.fromIdentifier(ctx.functionOperation().identifier());
            operation.parameters = ListIterate.collect(ctx.functionOperation().functionOperationArgument(), argCtx -> visitFunctionOperationArgument(argCtx, ingestPtr));
            operationElement = operation;
        }
        else if (ctx.columnOperation() != null)
        {
            operationElement = visitColumnOperation(ctx.columnOperation(), ingestPtr);
        }
        else if (ctx.constant() != null)
        {
            Literal constant = new Literal();
            constant.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
            if (ctx.constant().STRING() != null)
            {
                constant.value = PureGrammarParserUtility.fromGrammarString(ctx.constant().STRING().getText(), true);
            }
            else if (ctx.constant().INTEGER() != null)
            {
                constant.value = Integer.parseInt(ctx.constant().INTEGER().getText());
            }
            else if (ctx.constant().FLOAT() != null)
            {
                constant.value = Double.parseDouble(ctx.constant().FLOAT().getText());
            }
            else
            {
                throw new EngineException("Unsupported constant syntax", this.walkerSourceInformation.getSourceInformation(ctx), EngineErrorType.PARSER);
            }
            operationElement = constant;
        }
        else if (ctx.joinOperation() != null)
        {
            throw new EngineException("Join operations are not supported in Lakehouse mappings", this.walkerSourceInformation.getSourceInformation(ctx), EngineErrorType.PARSER);
        }
        if (operationElement == null)
        {
            throw new EngineException("Unsupported syntax", this.walkerSourceInformation.getSourceInformation(ctx), EngineErrorType.PARSER);
        }
        operationElement.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
        if (ctx.atomicOperationRight() != null)
        {
            DynaFunc operation = new DynaFunc();
            operation.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
            operation.parameters = new ArrayList<>();
            operation.parameters.add(operationElement);
            if (ctx.atomicOperationRight().atomicOperator() != null)
            {
                operation.funcName = visitAtomicOperator(ctx.atomicOperationRight().atomicOperator());
                operation.parameters.add(visitAtomicOperation(ctx.atomicOperationRight().atomicOperation(), ingestPtr));
            }
            else if (ctx.atomicOperationRight().atomicSelfOperator() != null)
            {
                operation.funcName = visitAtomicSelfOperator(ctx.atomicOperationRight().atomicSelfOperator());
            }
            else
            {
                throw new EngineException("Unsupported syntax", this.walkerSourceInformation.getSourceInformation(ctx), EngineErrorType.PARSER);
            }
            operationElement = operation;
        }
        return operationElement;
    }

    private String visitAtomicOperator(LakehouseMappingParserGrammar.AtomicOperatorContext ctx)
    {
        if (ctx.EQUAL() != null)
        {
            return "equal";
        }
        if (ctx.GREATER_THAN() != null)
        {
            return "greaterThan";
        }
        if (ctx.LESS_THAN() != null)
        {
            return "lessThan";
        }
        if (ctx.GREATER_OR_EQUAL() != null)
        {
            return "greaterThanEqual";
        }
        if (ctx.LESS_OR_EQUAL() != null)
        {
            return "lessThanEqual";
        }
        if (ctx.TEST_NOT_EQUAL() != null || ctx.NOT_EQUAL() != null)
        {
            return "notEqual";
        }
        throw new EngineException("Unsupported operator", this.walkerSourceInformation.getSourceInformation(ctx), EngineErrorType.PARSER);
    }

    private String visitAtomicSelfOperator(LakehouseMappingParserGrammar.AtomicSelfOperatorContext ctx)
    {
        if (ctx.IS_NULL() != null)
        {
            return "isNull";
        }
        if (ctx.IS_NOT_NULL() != null)
        {
            return "isNotNull";
        }
        throw new EngineException("Unsupported self operator", this.walkerSourceInformation.getSourceInformation(ctx), EngineErrorType.PARSER);
    }

    private RelationalOperationElement visitFunctionOperationArgument(LakehouseMappingParserGrammar.FunctionOperationArgumentContext ctx, IngestRelationAccessor ingestPtr)
    {
        if (ctx.operation() != null)
        {
            return visitOperation(ctx.operation(), ingestPtr);
        }
        throw new EngineException("Unsupported function argument syntax", this.walkerSourceInformation.getSourceInformation(ctx), EngineErrorType.PARSER);
    }

    private RelationalOperationElement visitColumnOperation(LakehouseMappingParserGrammar.ColumnOperationContext ctx, IngestRelationAccessor ingestPtr)
    {
        if (ctx.tableAliasColumnOperation() != null)
        {
            if (ctx.tableAliasColumnOperation().tableAliasColumnOperationWithTarget() != null)
            {
                return visitTableAliasColumnOperationWithTarget(ctx.tableAliasColumnOperation().tableAliasColumnOperationWithTarget(), ingestPtr);
            }
            else if (ctx.tableAliasColumnOperation().tableAliasColumnOperationWithScopeInfo() != null)
            {
                return visitTableAliasColumnOperationWithScopeInfo(ctx.tableAliasColumnOperation().tableAliasColumnOperationWithScopeInfo(), ingestPtr);
            }
        }
        throw new EngineException("Unsupported column operation syntax", this.walkerSourceInformation.getSourceInformation(ctx), EngineErrorType.PARSER);
    }

    private RelationalOperationElement visitTableAliasColumnOperationWithTarget(LakehouseMappingParserGrammar.TableAliasColumnOperationWithTargetContext ctx, IngestRelationAccessor ingestPtr)
    {
        IngestRelationColumn column = new IngestRelationColumn();
        column.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
        column.ingestAccessor = new IngestRelationAccessor();
        column.ingestAccessor.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
        String databasePath = ingestPtr.path.get(0); // Use the ingest source database
        String tableName = ctx.TARGET() != null ? ctx.TARGET().getText() : null;
        if (tableName == null)
        {
            throw new EngineException("Table name (TARGET) is required in column operation", this.walkerSourceInformation.getSourceInformation(ctx), EngineErrorType.PARSER);
        }
        column.ingestAccessor.path = Lists.mutable.with(databasePath, tableName);
        column.column = ctx.relationalIdentifier().QUOTED_STRING() != null
                ? PureGrammarParserUtility.fromGrammarString(ctx.relationalIdentifier().QUOTED_STRING().getText(), true)
                : PureGrammarParserUtility.fromIdentifier(ctx.relationalIdentifier().unquotedIdentifier());
        return column;
    }

    private RelationalOperationElement visitTableAliasColumnOperationWithScopeInfo(LakehouseMappingParserGrammar.TableAliasColumnOperationWithScopeInfoContext ctx, IngestRelationAccessor ingestPtr)
    {
        IngestRelationColumn column = new IngestRelationColumn();
        column.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
        column.ingestAccessor = new IngestRelationAccessor();
        column.ingestAccessor.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
        String databasePath = ingestPtr.path.get(0); // Use the ingest source database
        String tableName = ctx.relationalIdentifier().QUOTED_STRING() != null
                ? PureGrammarParserUtility.fromGrammarString(ctx.relationalIdentifier().QUOTED_STRING().getText(), true)
                : PureGrammarParserUtility.fromIdentifier(ctx.relationalIdentifier().unquotedIdentifier());
        column.ingestAccessor.path = Lists.mutable.with(databasePath, tableName);
        if (ctx.scopeInfo() != null && ctx.scopeInfo().relationalIdentifier().size() > 0)
        {
            column.column = ctx.scopeInfo().relationalIdentifier(0).QUOTED_STRING() != null
                    ? PureGrammarParserUtility.fromGrammarString(ctx.scopeInfo().relationalIdentifier(0).QUOTED_STRING().getText(), true)
                    : PureGrammarParserUtility.fromIdentifier(ctx.scopeInfo().relationalIdentifier(0).unquotedIdentifier());
        }
        else
        {
            throw new EngineException("Column name is required in scopeInfo", this.walkerSourceInformation.getSourceInformation(ctx), EngineErrorType.PARSER);
        }
        return column;
    }
}
