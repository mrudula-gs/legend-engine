lexer grammar CoreLexerGrammar;

import CoreFragmentGrammar;


// -------------------------------------- ACTION --------------------------------------

WHITESPACE:                                 Whitespace      -> skip;
COMMENT:                                    Comment         -> skip;
LINE_COMMENT:                               LineComment     -> skip;
ISLAND_OPEN:                                '#'  (~[#{])* '{'-> pushMode (ISLAND_MODE);


// -------------------------------------- TYPE --------------------------------------

STRING:                                     String;
BOOLEAN:                                    Boolean;
TRUE:                                       True;
FALSE:                                      False;
INTEGER:                                    Integer;
FLOAT:                                      Float;
DECIMAL:                                    Decimal;
DATE:                                       Date;
STRICTTIME:                                 StrictTime;
LATEST_DATE:                                '%latest';


// ----------------------------------- BUILDING BLOCK -----------------------------------

FILE_NAME:                                  FileName;
FILE_NAME_END:                              FileNameEnd;
PATH_SEPARATOR:                             PathSeparator;

AND:                                        '&&';
OR:                                         '||';
NOT:                                        '!';
COMMA:                                      ',';
EQUAL:                                      '=';
TEST_EQUAL:                                 '==';
TEST_NOT_EQUAL:                             '!=';
PERCENT:                                    '%';
ARROW:                                      '->';
BRACE_OPEN:                                 '{';
BRACE_CLOSE:                                '}';
BRACKET_OPEN:                               '[';
BRACKET_CLOSE:                              ']';
PAREN_OPEN:                                 '(';
PAREN_CLOSE:                                ')';
COLON:                                      ':';
DOT:                                        '.';
DOLLAR:                                     '$';
DOT_DOT:                                    '..';
SEMI_COLON:                                 ';';
NEW_SYMBOL:                                 '^';
PIPE:                                       '|';
TILDE:                                      '~';

AT:                                         '@';
PLUS:                                       '+';
STAR:                                       '*';
MINUS:                                      '-';
DIVIDE:                                     '/';
LESS_THAN:                                  '<';
LESS_OR_EQUAL:                              '<=';
GREATER_THAN:                               '>';
GREATER_OR_EQUAL:                           '>=';

VALID_STRING:                               ValidString;


// --------------------------------------- INVALID -------------------------------------------

INVALID:                                    Invalid;


// ----------------------------------- ISLAND GRAMMAR ------------------------------------

mode ISLAND_MODE;
ISLAND_START:                               '#{'        -> pushMode (ISLAND_MODE);
ISLAND_END:                                 '}#'        -> popMode;
ISLAND_HASH:                                '#';
ISLAND_BRACE_OPEN:                          '{';
ISLAND_BRACE_CLOSE:                         '}';
ISLAND_CONTENT:                             (~[{}#])+;




lexer grammar RelationalLexerGrammar;

import CoreLexerGrammar;


// -------------------------------------- KEYWORD --------------------------------------

DATABASE:                                   'Database';

INCLUDE:                                    'include';

TABLE:                                      'Table';
SCHEMA:                                     'Schema';
VIEW:                                       'View';
TABULAR_FUNC:                               'TabularFunction';
FILTER:                                     'Filter';
MULTIGRAIN_FILTER:                          'MultiGrainFilter';
JOIN:                                       'Join';

FILTER_CMD:                                 '~filter';
DISTINCT_CMD:                               '~distinct';
GROUP_BY_CMD:                               '~groupBy';
MAIN_TABLE_CMD:                             '~mainTable';
PRIMARY_KEY_CMD:                            '~primaryKey';

TARGET:                                     '{target}';
PRIMARY_KEY:                                'PRIMARY KEY';
NOT_NULL:                                   'NOT NULL';
IS_NULL:                                    'is null';
IS_NOT_NULL:                                'is not null';
AND:                                        'and';
OR:                                         'or';

// Milestoning
MILESTONING:                                'milestoning';
BUSINESS_MILESTONING:                       'business';
BUSINESS_MILESTONING_FROM:                  'BUS_FROM';
BUSINESS_MILESTONING_THRU:                  'BUS_THRU';
THRU_IS_INCLUSIVE:                          'THRU_IS_INCLUSIVE';
BUS_SNAPSHOT_DATE:                          'BUS_SNAPSHOT_DATE';
PROCESSING_MILESTONING:                     'processing';
PROCESSING_MILESTONING_IN:                  'PROCESSING_IN';
PROCESSING_MILESTONING_OUT:                 'PROCESSING_OUT';
OUT_IS_INCLUSIVE:                           'OUT_IS_INCLUSIVE';
INFINITY_DATE:                              'INFINITY_DATE';
PROCESSING_SNAPSHOT_DATE:                   'PROCESSING_SNAPSHOT_DATE';

// Mapping
ASSOCIATION_MAPPING:                        'AssociationMapping';
ENUMERATION_MAPPING:                        'EnumerationMapping';
OTHERWISE:                                  'Otherwise';
INLINE:                                     'Inline';
BINDING:                                    'Binding';

SCOPE:                                      'scope';


// ----------------------------------- BUILDING BLOCK -----------------------------------

NOT_EQUAL:                                  '<>';
FLOAT:                                      ('+' | '-')? Float;
INTEGER:                                    ('+' | '-')? Integer;
QUOTED_STRING:                              ('"' ( EscSeq | ~["\r\n] )*  '"');





parser grammar CoreParserGrammar;

qualifiedName:                                  (packagePath PATH_SEPARATOR)? identifier
;
packagePath:                                    identifier (PATH_SEPARATOR identifier)*
;

// Since BOOLEAN and INTEGER overlap with VALID_STRING, we have to account for them
// Also, here, we use `identifier` instead of VALID_STRING
// because in the main grammar, we will take care of keywords overlapping VALID_STRING
word:                                           identifier | BOOLEAN | INTEGER
;

islandDefinition:                           ISLAND_OPEN islandContent
;

islandContent:                              (ISLAND_START | ISLAND_BRACE_OPEN | ISLAND_CONTENT | ISLAND_HASH | ISLAND_BRACE_CLOSE | ISLAND_END)*
;



parser grammar RelationalParserGrammar;

import CoreParserGrammar;

options
{
    tokenVocab = RelationalLexerGrammar;
}


// -------------------------------------- IDENTIFIER --------------------------------------

unquotedIdentifier:                         VALID_STRING
                                            | DATABASE | INCLUDE
                                            | SCHEMA | TABLE | VIEW | JOIN | FILTER | MULTIGRAIN_FILTER
                                            | AND | OR
                                            | MILESTONING | BUSINESS_MILESTONING | BUSINESS_MILESTONING_FROM | BUSINESS_MILESTONING_THRU
                                            | OUT_IS_INCLUSIVE | THRU_IS_INCLUSIVE | INFINITY_DATE | BUS_SNAPSHOT_DATE
                                            | PROCESSING_MILESTONING | PROCESSING_MILESTONING_IN | PROCESSING_MILESTONING_OUT | PROCESSING_SNAPSHOT_DATE
                                            | SCOPE | ENUMERATION_MAPPING | ASSOCIATION_MAPPING | OTHERWISE | INLINE | BINDING | TABULAR_FUNC
;

identifier:                                 unquotedIdentifier | STRING
;

// -------------------------------------- DEFINITION --------------------------------------

definition:                                 (database)*
                                            EOF
;
database:                                   DATABASE stereotypes? taggedValues? qualifiedName
                                                PAREN_OPEN
                                                    include*
                                                    (
                                                        schema
                                                        | table
                                                        | view
                                                        | join
                                                        | tabularFunction
                                                        | filter
                                                        | multiGrainFilter
                                                    )*
                                                PAREN_CLOSE
;
include:                                    INCLUDE qualifiedName
;

// -------------------------------------- STEREOTYPE --------------------------------------

stereotypes:                        LESS_THAN LESS_THAN stereotype (COMMA stereotype)* GREATER_THAN GREATER_THAN;

stereotype:                         qualifiedName DOT identifier;

taggedValues:                                   BRACE_OPEN taggedValue (COMMA taggedValue)* BRACE_CLOSE
;
taggedValue:                                    qualifiedName DOT identifier EQUAL STRING
;

// -------------------------------------- SCHEMA & TABLE --------------------------------------

schema:                                     SCHEMA stereotypes? taggedValues? schemaIdentifier
                                                PAREN_OPEN
                                                    (
                                                        table
                                                        | view
                                                        | tabularFunction
                                                    )*
                                                PAREN_CLOSE
;
table:                                      TABLE stereotypes? taggedValues? relationalIdentifier
                                                PAREN_OPEN
                                                    milestoneSpec?
                                                    (columnDefinition (COMMA columnDefinition)*)?
                                                PAREN_CLOSE
;
columnDefinition:                           relationalIdentifier stereotypes? taggedValues? identifier (PAREN_OPEN INTEGER (COMMA INTEGER)? PAREN_CLOSE)? (PRIMARY_KEY | NOT_NULL)?
;

// -------------------------------------- MILESTONING --------------------------------------

milestoneSpec:                              MILESTONING
                                                PAREN_OPEN
                                                    (milestoning (COMMA milestoning)*)?
                                                PAREN_CLOSE
;
milestoning:                                milestoningType
                                                PAREN_OPEN
                                                    milestoningSpecification
                                                PAREN_CLOSE
;
milestoningType:                            identifier
;
milestoningSpecification:                   (relationalIdentifier | COMMA | BOOLEAN | DATE | EQUAL)*
;
businessMilestoning:                        BUSINESS_MILESTONING
                                                PAREN_OPEN
                                                    (
                                                        businessMilestoningFromThru
                                                        | businessSnapshotDate
                                                    )
                                                PAREN_CLOSE
;
businessMilestoningFromThru:                BUSINESS_MILESTONING_FROM EQUAL identifier COMMA
                                            BUSINESS_MILESTONING_THRU EQUAL identifier
                                            (COMMA THRU_IS_INCLUSIVE EQUAL BOOLEAN)?
                                            (COMMA INFINITY_DATE EQUAL DATE)?
;
businessSnapshotDate:                       BUS_SNAPSHOT_DATE EQUAL identifier
;
processingMilestoning:                      PROCESSING_MILESTONING
                                                PAREN_OPEN
                                                    (
                                                        processingMilestoningInOut
                                                        | processingSnapshotDate
                                                    )
                                                PAREN_CLOSE
;
processingMilestoningInOut:                 PROCESSING_MILESTONING_IN EQUAL identifier COMMA
                                            PROCESSING_MILESTONING_OUT EQUAL identifier
                                            (COMMA OUT_IS_INCLUSIVE EQUAL BOOLEAN)?
                                            (COMMA INFINITY_DATE EQUAL DATE)?
;
processingSnapshotDate:                     PROCESSING_SNAPSHOT_DATE EQUAL identifier
;
// -------------------------------------- VIEW --------------------------------------

view:                                       VIEW stereotypes? taggedValues?  relationalIdentifier
                                                PAREN_OPEN
                                                    (viewFilterMapping)?
                                                    (viewGroupBy)?
                                                    (DISTINCT_CMD)?
                                                    (viewColumnMapping (COMMA viewColumnMapping)*)?
                                                PAREN_CLOSE
;
viewFilterMapping:                          FILTER_CMD (viewFilterMappingJoin | databasePointer)? identifier
;
viewFilterMappingJoin:                      databasePointer joinSequence PIPE databasePointer
;
viewGroupBy:                                GROUP_BY_CMD
                                                PAREN_OPEN
                                                    (operation (COMMA operation)*)?
                                                PAREN_CLOSE
;
viewColumnMapping:                          identifier (BRACKET_OPEN identifier BRACKET_CLOSE)? COLON operation PRIMARY_KEY?
;

// -------------------------------------- TABULAR FUNCTION --------------------------------------
tabularFunction:                               TABULAR_FUNC relationalIdentifier
                                                PAREN_OPEN
                                                    (columnDefinition (COMMA columnDefinition)*)?
                                                PAREN_CLOSE
;


// -------------------------------------- FILTER & JOIN --------------------------------------

filter:                                     FILTER identifier PAREN_OPEN operation PAREN_CLOSE
;
multiGrainFilter:                           MULTIGRAIN_FILTER identifier PAREN_OPEN operation PAREN_CLOSE
;
join:                                       JOIN identifier PAREN_OPEN operation PAREN_CLOSE
;

// -------------------------------------- OPERATIONS --------------------------------------

// NOTE: we have the `...Right` parser rule to avoid mutually left-recursive rules. For example, the rule
// `booleanOperation: operation booleanOperator operation` will cause ANTLR to throw error
// See https://github.com/antlr/antlr4/blob/master/doc/left-recursion.md
//
// Also note that we split the rule `operation` because in `joinOperation` we cannot directly use `joinOperation` as the operation
//
// IMPORTANT: Notice the way we construct `booleanOperation`, and `atomicOperation` which
// forms a hierarchy/precedence. The gist of this is:
//  - The more deeply nested the parser rule, the higher the precedence it is
//  - The higher precedence rule should use only token of precedence equals or higher than itself
//    (i.e. `atomicOperation` should not use `booleanOperation` in its parser definition)
// See https://stackoverflow.com/questions/1451728/antlr-operator-precedence

operation:                                  booleanOperation
                                            | joinOperation
;
booleanOperation:                           atomicOperation booleanOperationRight?
;
booleanOperationRight:                      booleanOperator operation
;
booleanOperator:                            AND | OR
;
atomicOperation:                            (
                                                groupOperation
                                                | ( databasePointer? functionOperation )
                                                | columnOperation
                                                | joinOperation
                                                | constant
                                            )
                                            atomicOperationRight?
;
atomicOperationRight:                       (atomicOperator atomicOperation) | atomicSelfOperator
;
atomicOperator:                             EQUAL | TEST_NOT_EQUAL | NOT_EQUAL | GREATER_THAN | LESS_THAN | GREATER_OR_EQUAL | LESS_OR_EQUAL
;
atomicSelfOperator:                         IS_NULL | IS_NOT_NULL
;
groupOperation:                             PAREN_OPEN operation PAREN_CLOSE
;
constant:                                   STRING | INTEGER | FLOAT
;
functionOperation:                          identifier PAREN_OPEN (functionOperationArgument (COMMA functionOperationArgument)*)? PAREN_CLOSE
;
functionOperationArgument:                  operation | functionOperationArgumentArray
;
functionOperationArgumentArray:             BRACKET_OPEN (functionOperationArgument (COMMA functionOperationArgument)*)? BRACKET_CLOSE
;
columnOperation:                            databasePointer? tableAliasColumnOperation
;
tableAliasColumnOperation:                  tableAliasColumnOperationWithTarget | tableAliasColumnOperationWithScopeInfo
;
tableAliasColumnOperationWithTarget:        TARGET DOT relationalIdentifier
;
tableAliasColumnOperationWithScopeInfo:     relationalIdentifier (DOT scopeInfo)?
;
joinOperation:                              databasePointer? joinSequence (PIPE (booleanOperation | tableAliasColumnOperation))?
;
joinSequence:                               (PAREN_OPEN identifier PAREN_CLOSE)? joinPointer (GREATER_THAN joinPointerFull)*
;
joinPointer:                                AT identifier
;
joinPointerFull:                            (PAREN_OPEN identifier PAREN_CLOSE)? databasePointer? joinPointer
;


// -------------------------------------- RELATIONAL MAPPING --------------------------------------

// NOTE: Order must be preserved here as we want the associationMapping rule to be mapped as an associationMapping
// not as an embedded property mapping
mapping:                                    associationMapping | classMapping
;
associationMapping:                         ASSOCIATION_MAPPING
                                                PAREN_OPEN
                                                    propertyMapping (COMMA propertyMapping)*
                                                PAREN_CLOSE
                                                EOF
;
classMapping:                               mappingFilter?
                                            DISTINCT_CMD?
                                            mappingGroupBy?
                                            mappingPrimaryKey?
                                            mappingMainTable?
                                            (propertyMapping (COMMA propertyMapping)*)?
                                            EOF
;
mappingFilter:                              FILTER_CMD databasePointer (joinSequence PIPE databasePointer)? identifier
;
mappingGroupBy:                             GROUP_BY_CMD
                                                PAREN_OPEN
                                                    (operation (COMMA operation)*)?
                                                PAREN_CLOSE
;
mappingPrimaryKey:                          PRIMARY_KEY_CMD
                                                PAREN_OPEN
                                                    (operation (COMMA operation)*)?
                                                PAREN_CLOSE
;
mappingMainTable:                           MAIN_TABLE_CMD databasePointer mappingScopeInfo
;
mappingScopeInfo:                           relationalIdentifier (DOT scopeInfo)?
;


// -------------------------------------- PROPERTY MAPPING --------------------------------------

propertyMapping:                            singlePropertyMapping | propertyMappingWithScope
;
propertyMappingWithScope:                   SCOPE PAREN_OPEN databasePointer mappingScopeInfo? PAREN_CLOSE
                                                PAREN_OPEN
                                                    singlePropertyMapping (COMMA singlePropertyMapping)*
                                                PAREN_CLOSE
;
singlePropertyMapping:                      singlePropertyMappingWithPlus | singlePropertyMappingWithoutPlus
;
singlePropertyMappingWithPlus:              PLUS identifier localMappingProperty relationalPropertyMapping
;
singlePropertyMappingWithoutPlus:           identifier sourceAndTargetMappingId?
                                            (
                                                relationalPropertyMapping
                                                | embeddedPropertyMapping
                                                | inlineEmbeddedPropertyMapping
                                            )
;
sourceAndTargetMappingId:                   BRACKET_OPEN sourceId (COMMA targetId)? BRACKET_CLOSE
;
sourceId:                                   identifier
;
targetId:                                   identifier
;
relationalPropertyMapping:                  COLON (transformer)? operation
;
transformer:                                enumTransformer | bindingTransformer
;
enumTransformer:                            ENUMERATION_MAPPING identifier COLON
;
bindingTransformer:                         BINDING qualifiedName COLON
;


// -------------------------------------- LOCAL MAPPING PROPERTY --------------------------------------

localMappingProperty:                       COLON qualifiedName BRACKET_OPEN (localMappingPropertyFromMultiplicity DOT_DOT)? localMappingPropertyToMultiplicity BRACKET_CLOSE
;
localMappingPropertyFromMultiplicity:       INTEGER | STAR
;
localMappingPropertyToMultiplicity:         INTEGER | STAR
;


// -------------------------------------- EMBEDDED PROPERTY MAPPING --------------------------------------

embeddedPropertyMapping:                    PAREN_OPEN
                                            (
                                                mappingPrimaryKey?
                                                singlePropertyMapping (COMMA singlePropertyMapping)*
                                            )?
                                            PAREN_CLOSE (otherwiseEmbeddedPropertyMapping)?
;
inlineEmbeddedPropertyMapping:              PAREN_OPEN PAREN_CLOSE INLINE BRACKET_OPEN identifier BRACKET_CLOSE
;
otherwiseEmbeddedPropertyMapping:           OTHERWISE PAREN_OPEN otherwisePropertyMapping PAREN_CLOSE
;
otherwisePropertyMapping:                   BRACKET_OPEN identifier BRACKET_CLOSE COLON databasePointer? joinSequence
;


// -------------------------------------- BUILDING BLOCK --------------------------------------

scopeInfo:                                  relationalIdentifier (DOT relationalIdentifier)?
;
databasePointer:                            BRACKET_OPEN qualifiedName BRACKET_CLOSE
;
relationalIdentifier:                       unquotedIdentifier | QUOTED_STRING
;
// Should be the same as relationalIdentifier, but it currently breaks some projects
schemaIdentifier:                           identifier | QUOTED_STRING
;



the rules exactly that were used for the expression : #>{a::A.tb}#->join(#>{a::A.tb2}#, meta::pure::functions::relation::JoinKind.INNER, {a,b|$a.id == $b.id2})

    @Test
    public void testJoin()
    {
        test(
                "###Relational\n" +
                        "Database a::A (" +
                        "   Table tb(id Integer, other VARCHAR(200))" +
                        "   Table tb2(id2 Integer, errr VARCHAR(200))" +
                        ")\n" +
                        "\n" +
                        "###Pure\n" +
                        "function test::f():Any[*]\n" +
                        "{\n" +
                        "   #>{a::A.tb}#->join(#>{a::A.tb2}#, meta::pure::functions::relation::JoinKind.INNER, {a,b|$a.id == $b.id2})\n" +
                        "}"
        );
    }


The provided ANTLR lexer and parser grammars define a structure for parsing expressions, including specific components found in the given example. However, the grammar snippets are incomplete for fully parsing the expression `#{a::A.tb}#->join(#>{a::A.tb2}#, meta::pure::functions::relation::JoinKind.INNER, {a,b|$a.id == $b.id2})`. Below is an explanation of the rules that *would* be used if the grammar were complete, and where the current grammar has omissions.

The expression can be broadly divided into three main parts: a source expression, a chaining operator, and a function call.

### 1. Source Component: `#>{a::A.tb}#`

This construct represents a reference to a database table.
*   **Lexical Analysis**:
    *   `#{`: This sequence would likely be tokenized as `ISLAND_START`. The `ISLAND_START` rule pushes the lexer into `ISLAND_MODE`.
    *   `a::A.tb`: While in `ISLAND_MODE`, the content `a::A.tb` would be tokenized. The `ISLAND_CONTENT` rule generally captures any characters not `{}#`. In a more refined grammar, the internal parts (`a`, `::`, `A`, `.`, `tb`) might be tokenized individually, but based solely on `ISLAND_CONTENT`, it would be a single block.
    *   `}#`: This sequence would be tokenized as `ISLAND_END`, which pops the lexer out of `ISLAND_MODE`.
*   **Syntactic Analysis**: The `RelationalParserGrammar` defines `databasePointer` as `BRACKET_OPEN qualifiedName BRACKET_CLOSE`. This rule expects `[` and `]` tokens. The literal `#{...}#` does not directly map to this `databasePointer` rule with the provided tokens. However, in such grammars, `#{...}#` is often treated as a special literal or embedded expression that *represents* a `databasePointer` for the parser. Assuming it is resolved to a `databasePointer`:
    *   The content `a::A.tb` would be interpreted as a `qualifiedName`.
        *   `a::A`: This part matches `packagePath` (where `a` is an `identifier` and `A` is an `identifier`, separated by `PATH_SEPARATOR`).
        *   `.tb`: The `DOT` and `tb` (an `identifier`) are used to further qualify the name. While the `qualifiedName` rule itself is `(packagePath PATH_SEPARATOR)? identifier`, the pattern `qualifiedName DOT identifier` is used elsewhere in the grammar (e.g., for `stereotype` and `taggedValue`), implying that such a structure is recognized for element references.

### 2. Chaining Operator: `->`

*   **Lexical Analysis**: `->` is explicitly defined as the `ARROW` token in `CoreLexerGrammar`.
*   **Syntactic Analysis**: The provided `RelationalParserGrammar` **does not contain any parser rule that consumes the `ARROW` token to chain operations** (e.g., a rule like `expression ARROW functionCall`). This is a significant omission in the provided grammar for parsing this specific expression. Therefore, the parsing of the `->` operator for chaining is not explicitly defined by the given rules.

### 3. Function Call Component: `join(#>{a::A.tb2}#, meta::pure::functions::relation::JoinKind.INNER, {a,b|$a.id == $b.id2})`

This part clearly matches the `functionOperation` rule in `RelationalParserGrammar`: `identifier PAREN_OPEN (functionOperationArgument (COMMA functionOperationArgument)*)? PAREN_CLOSE`.
*   `identifier`: `join` (which is an `unquotedIdentifier`).
*   `PAREN_OPEN`: `(`.
*   The arguments are separated by `COMMA` and are parsed as `functionOperationArgument` which can be an `operation` or `functionOperationArgumentArray`.

    *   **First Argument: `#>{a::A.tb2}#`**
        *   This is another instance of the special `databasePointer` literal. Its lexical and assumed syntactic analysis would follow the same pattern as the initial source component `#{a::A.tb}#`, resolving to a `databasePointer` representing `a::A.tb2`. It would be consumed as an `operation`.

    *   **Second Argument: `meta::pure::functions::relation::JoinKind.INNER`**
        *   This is a `qualifiedName`.
            *   `meta::pure::functions::relation`: This forms a `packagePath` using `PATH_SEPARATOR` and `identifier`s.
            *   `JoinKind`: This is an `identifier`.
            *   `.INNER`: The `DOT` and `INNER` (an `identifier`) are part of qualifying the name, similar to `a::A.tb`. This is interpreted as a reference to an enumeration member or static property. It would be consumed as an `operation`.

    *   **Third Argument: `{a,b|$a.id == $b.id2}`**
        *   **Lexical Analysis**: This argument involves several tokens: `BRACE_OPEN` (`{`), `identifier` (`a`), `COMMA` (`,`), `identifier` (`b`), `PIPE` (`|`), `DOLLAR` (`$`), `identifier` (`a`), `DOT` (`.`), `relationalIdentifier` (`id`), `TEST_EQUAL` (`==`), `DOLLAR` (`$`), `identifier` (`b`), `DOT` (`.`), `relationalIdentifier` (`id2`), `BRACE_CLOSE` (`}`).
        *   **Syntactic Analysis**: The provided grammar **does not explicitly define a rule for a lambda expression** that uses `BRACE_OPEN`, parameters, `PIPE`, and `BRACE_CLOSE` to enclose an `operation`. This is another significant omission. However, if such a rule existed, the inner expression `$a.id == $b.id2` would be an `operation`, specifically a `booleanOperation` composed of `atomicOperation`s and an `atomicOperator`.
            *   `$a.id`: This would be an `atomicOperation`. However, the `DOLLAR` token is defined but **not explicitly consumed by any `columnOperation` or `atomicOperation` rule** in the provided grammar for variable/parameter access like `$identifier.field`. This is a third significant omission. If it were part of `columnOperation`, it would rely on an unlisted rule that captures `DOLLAR relationalIdentifier (DOT scopeInfo)?`.
            *   `==`: This is an `atomicOperator` (`TEST_EQUAL`).
            *   `$b.id2`: This would be the second `atomicOperation`, processed similarly to `$a.id`.
*   `PAREN_CLOSE`: `)`.

In conclusion, while many tokens and basic parsing rules are defined, the provided grammar snippets are insufficient to fully parse the `->` chaining operator, the `#{...}#` literal interpretation as a `databasePointer` (beyond basic tokenization), the lambda expression ` {a,b|$a.id == $b.id2} `, and the `$variable.field` parameter/variable access. Additional or more generalized rules would be required for a complete parse.
