parser grammar LakehouseMappingParserGrammar;
import CoreParserGrammar;

options
{
    tokenVocab = LakehouseMappingLexerGrammar;
}

// -------------------------------------- IDENTIFIER --------------------------------------

unquotedIdentifier:                         VALID_STRING
                                            | ALL | LET | ALL_VERSIONS | ALL_VERSIONS_IN_RANGE
                                            | TO_BYTES_FUNCTION
                                            | INGEST_SOURCE_CMD | ACCESS_POINT_SOURCE_CMD
;

identifier:                                 unquotedIdentifier | STRING
;

// -------------------------------------- LAKEHOUSE MAPPING DEFINITION --------------------------------------

lakehouseClassMapping:                      (ingestSrc | accessPointSrc)
                                                (propertyMapping (COMMA propertyMapping)*)?
                                            EOF
;
ingestSrc:                                  INGEST_SOURCE_CMD databasePointer qualifiedName
;
accessPointSrc:                             ACCESS_POINT_SOURCE_CMD databasePointer qualifiedName
;
propertyMapping:                            qualifiedName STAR? COLON operation (PIPE operation)?
;
mappingScopeInfo:                           unquotedIdentifier
;

// -------------------------------------- OPERATION --------------------------------------
operation: booleanOperation
;

// Boolean operations (AND, OR) have lowest precedence
booleanOperation: comparisonOperation (booleanOperator comparisonOperation)*
;

booleanOperator: AND | OR
;

// Comparison operations (==, !=, <, >, <=, >=) have higher precedence than boolean
comparisonOperation: additiveOperation (comparisonOperator additiveOperation)?
;

comparisonOperator: TEST_EQUAL | TEST_NOT_EQUAL | LESS_THAN | GREATER_THAN | LESS_OR_EQUAL | GREATER_OR_EQUAL
;

// For now, we'll keep additive operations simple (can be extended later for +, -, etc.)
additiveOperation: atomicExpression
;

atomicExpression: functionExpression
                | columnOperation
                | constant
                | anyLambda
                | PAREN_OPEN operation PAREN_CLOSE
;

functionExpression: (databasePointer identifier ARROW)? identifier functionExpressionParameters
;

functionExpressionParameters: PAREN_OPEN (functionOperationArgument (COMMA functionOperationArgument)*)? PAREN_CLOSE
;

functionOperationArgument: qualifiedName DOT identifier
                         | databasePointer identifier
                         | anyLambda
                         | operation
;

anyLambda: BRACE_OPEN (lambdaParam (COMMA lambdaParam)*)? PIPE operation BRACE_CLOSE
;

lambdaParam: identifier
;

columnOperation: databasePointer? tableAliasColumnOperation 
               | variable DOT relationalIdentifier
;

tableAliasColumnOperation: tableAliasColumnOperationWithScopeInfo
;

tableAliasColumnOperationWithScopeInfo: relationalIdentifier (DOT scopeInfo)?
;

variable: DOLLAR identifier
;

constant: STRING | INTEGER | FLOAT
;

// -------------------------------------- BUILDING BLOCK --------------------------------------

scopeInfo: relationalIdentifier (DOT relationalIdentifier)?
;
databasePointer: BRACKET_OPEN qualifiedName BRACKET_CLOSE
;
relationalIdentifier: unquotedIdentifier | QUOTED_STRING
;




// Replace the visitOperation method with this:
private RelationalOperationElement visitOperation(LakehouseMappingParserGrammar.OperationContext ctx, IngestRelationAccessor ingestPtr, LambdaContext lambdaContext)
{
    // Since operation now directly contains booleanOperation
    return visitBooleanOperation(ctx.booleanOperation(), ingestPtr, lambdaContext);
}

// Update visitBooleanOperation to handle the new grammar structure:
private RelationalOperationElement visitBooleanOperation(LakehouseMappingParserGrammar.BooleanOperationContext ctx, IngestRelationAccessor ingestPtr, LambdaContext lambdaContext)
{
    List<LakehouseMappingParserGrammar.ComparisonOperationContext> comparisons = ctx.comparisonOperation();
    List<LakehouseMappingParserGrammar.BooleanOperatorContext> operators = ctx.booleanOperator();
    
    if (comparisons.size() == 1)
    {
        // No boolean operators, just a single comparison
        return visitComparisonOperation(comparisons.get(0), ingestPtr, lambdaContext);
    }
    
    // Build left-associative tree of boolean operations
    RelationalOperationElement left = visitComparisonOperation(comparisons.get(0), ingestPtr, lambdaContext);
    
    for (int i = 0; i < operators.size(); i++)
    {
        DynaFunc operation = new DynaFunc();
        operation.sourceInformation = this.walkerSourceInformation.getSourceInformation(operators.get(i));
        operation.funcName = operators.get(i).AND() != null ? "and" : "or";
        operation.parameters = new ArrayList<>();
        operation.parameters.add(left);
        operation.parameters.add(visitComparisonOperation(comparisons.get(i + 1), ingestPtr, lambdaContext));
        left = operation;
    }
    
    return left;
}

// Add new method for comparison operations:
private RelationalOperationElement visitComparisonOperation(LakehouseMappingParserGrammar.ComparisonOperationContext ctx, IngestRelationAccessor ingestPtr, LambdaContext lambdaContext)
{
    List<LakehouseMappingParserGrammar.AdditiveOperationContext> additives = ctx.additiveOperation();
    
    if (additives.size() == 1)
    {
        // No comparison operator
        return visitAdditiveOperation(additives.get(0), ingestPtr, lambdaContext);
    }
    
    // Has comparison operator
    DynaFunc operation = new DynaFunc();
    operation.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
    
    LakehouseMappingParserGrammar.ComparisonOperatorContext opCtx = ctx.comparisonOperator(0);
    if (opCtx.TEST_EQUAL() != null)
    {
        operation.funcName = "equal";
    }
    else if (opCtx.TEST_NOT_EQUAL() != null)
    {
        operation.funcName = "notEqual";
    }
    else if (opCtx.LESS_THAN() != null)
    {
        operation.funcName = "lessThan";
    }
    else if (opCtx.GREATER_THAN() != null)
    {
        operation.funcName = "greaterThan";
    }
    else if (opCtx.LESS_OR_EQUAL() != null)
    {
        operation.funcName = "lessThanEqual";
    }
    else if (opCtx.GREATER_OR_EQUAL() != null)
    {
        operation.funcName = "greaterThanEqual";
    }
    
    operation.parameters = new ArrayList<>();
    operation.parameters.add(visitAdditiveOperation(additives.get(0), ingestPtr, lambdaContext));
    operation.parameters.add(visitAdditiveOperation(additives.get(1), ingestPtr, lambdaContext));
    
    return operation;
}

// Add new method for additive operations (currently just passes through to atomic):
private RelationalOperationElement visitAdditiveOperation(LakehouseMappingParserGrammar.AdditiveOperationContext ctx, IngestRelationAccessor ingestPtr, LambdaContext lambdaContext)
{
    // For now, additive operations just pass through to atomic expressions
    // This can be extended later to handle +, -, *, / etc.
    return visitAtomicExpression(ctx.atomicExpression(), ingestPtr, lambdaContext);
}

// Update visitAtomicExpression to handle the new structure:
private RelationalOperationElement visitAtomicExpression(LakehouseMappingParserGrammar.AtomicExpressionContext ctx, IngestRelationAccessor ingestPtr, LambdaContext lambdaContext)
{
    if (ctx.functionExpression() != null)
    {
        return visitFunctionExpression(ctx.functionExpression(), ingestPtr, lambdaContext);
    }
    else if (ctx.columnOperation() != null)
    {
        return visitColumnOperation(ctx.columnOperation(), ingestPtr, lambdaContext);
    }
    else if (ctx.constant() != null)
    {
        Literal constant = new Literal();
        constant.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
        if (ctx.constant().STRING() != null)
        {
            constant.value = PureGrammarParserUtility.fromGrammarString(ctx.constant().STRING().getText(), true);
        }
        else if (ctx.constant().INTEGER() != null)
        {
            constant.value = Integer.parseInt(ctx.constant().INTEGER().getText());
        }
        else if (ctx.constant().FLOAT() != null)
        {
            constant.value = Double.parseDouble(ctx.constant().FLOAT().getText());
        }
        else
        {
            throw new EngineException("Unsupported constant syntax", this.walkerSourceInformation.getSourceInformation(ctx), EngineErrorType.PARSER);
        }
        return constant;
    }
    else if (ctx.anyLambda() != null)
    {
        return visitAnyLambda(ctx.anyLambda(), ingestPtr, lambdaContext);
    }
    else if (ctx.operation() != null)
    {
        // Parenthesized expression
        return visitOperation(ctx.operation(), ingestPtr, lambdaContext);
    }
    throw new EngineException("Unsupported atomic expression syntax", this.walkerSourceInformation.getSourceInformation(ctx), EngineErrorType.PARSER);
}

// Remove the old visitExpression method as it's no longer needed
