    @Test
    public void testLakehouseMappingJoin()
    {
        test("###Lakehouse\n" +
                "Ingest test::ingest::FirmIngest AppendOnly Undefined<CSV> owner=AppDir(prodParallel='1') group=test\n" +
                "[\n" +
                "   Firm(\n" +
                "      id: Varchar(200)[1],\n" +
                        "      idF: Varchar(200)[1],\n" +
                "      legalName: Varchar(200)[1]\n" +
                "   )\n" +
                "   DP10;\n" +
                "]\n" +
                "\n" +
                "\n" +
                "Ingest test::ingest::PersonIngest BatchMilestoned Snapshot<CSV> owner=AppDir(prodParallel='1') group=test\n" +
                "[\n" +
                "   Person(\n" +
                "      last_name: Varchar(200)[1],\n" +
                        "      idP: Varchar(200)[1],\n" +
                "      firm_id: Varchar(200)[1]\n" +
                "   )\n" +
                "   DP10\n" +
                "   pk=[firm_id];\n" +
                "]\n" +
                "\n" +
//                "###Pure\n" +
//                "function test::myFunc():meta::pure::metamodel::relation::Relation<Any>[1]\n" +
//                "{\n" +
//                "  test::model::Person.all()->project(~[firmID:x|$x.firm_id, Name:x|$x.lastName])->from(test::mapping::MyMap1, my::DuckDBRuntime)\n" +
//                "}\n" +
                "\n" +
                "\n" +
                "###Pure\n" +
                "Class test::model::Firm\n" +
                "{\n" +
                        "  IDF: String[1];\n" +
                "  id: String[1];\n" +
                "  legalName: String[1];\n" +
                "}\n" +
                "\n" +
                "Class test::model::Person\n" +
                "{\n" +
                        "  IDP: String[1];\n" +
                "  lastName: String[1];\n" +
                "  firm_id: Firm[1];\n" +
                "}\n" +
                "\n" +
                "\n" +
                "###Mapping\n" +
                "Mapping test::mapping::MyMap1\n" +
                "(\n" +
                "  test::model::Person: Lakehouse\n" +
                "  {\n" +
                "    ~ingestSource [test::ingest::PersonIngest]Person\n" +
                "    lastName: toUpper([test::ingest::PersonIngest]Person.last_name),\n" +
                "    firm_id: [test::ingest::PersonIngest]Person->join([test::ingest::FirmIngest]Firm, meta::pure::functions::relation::JoinKind.INNER, {x, y|$x.firm_id == $y.firm_id && $x.idP == $y.idF}) | [test::ingest::FirmIngest]Firm.id\n" +
                "  }\n" +
                ")\n"
        );
    }



parser grammar LakehouseMappingParserGrammar;
import CoreParserGrammar;

options
{
    tokenVocab = LakehouseMappingLexerGrammar;
}

// -------------------------------------- IDENTIFIER --------------------------------------

unquotedIdentifier:                         VALID_STRING
                                            | ALL | LET | ALL_VERSIONS | ALL_VERSIONS_IN_RANGE
                                            | TO_BYTES_FUNCTION
                                            | INGEST_SOURCE_CMD | ACCESS_POINT_SOURCE_CMD
;

identifier:                                 unquotedIdentifier | STRING
;

// -------------------------------------- LAKEHOUSE MAPPING DEFINITION --------------------------------------

lakehouseClassMapping:                      (ingestSrc | accessPointSrc)
                                                (propertyMapping (COMMA propertyMapping)*)?
                                            EOF
;
ingestSrc:                                  INGEST_SOURCE_CMD databasePointer qualifiedName
;
accessPointSrc:                             ACCESS_POINT_SOURCE_CMD databasePointer qualifiedName
;
propertyMapping:                            qualifiedName STAR? COLON operation (PIPE operation)?
;
mappingScopeInfo:                           unquotedIdentifier
;

// -------------------------------------- OPERATION --------------------------------------
operation: functionExpression
         | booleanOperation
         | expression
;

functionExpression: (databasePointer identifier ARROW)? identifier functionExpressionParameters
;

functionExpressionParameters: PAREN_OPEN (functionOperationArgument (COMMA functionOperationArgument)*)? PAREN_CLOSE
;

functionOperationArgument: qualifiedName DOT identifier
                            | databasePointer identifier
                            | anyLambda
                            |  operation
;

anyLambda: BRACE_OPEN (lambdaParam (COMMA lambdaParam)*)? PIPE operation BRACE_CLOSE
;

lambdaParam: identifier
;

booleanOperation:                           atomicExpression booleanOperationRight?
;
booleanOperationRight:                      booleanOperator operation
;
booleanOperator:                            AND | OR
;
expression: atomicExpression (equalNotEqual)?
;

equalNotEqual: (TEST_EQUAL | TEST_NOT_EQUAL) atomicExpression
;

atomicExpression: columnOperation
                | constant
                | anyLambda
                | PAREN_OPEN operation PAREN_CLOSE
;

columnOperation: databasePointer? tableAliasColumnOperation | variable DOT relationalIdentifier
;

tableAliasColumnOperation:   tableAliasColumnOperationWithScopeInfo
;

tableAliasColumnOperationWithScopeInfo:     relationalIdentifier (DOT scopeInfo)?
;

variable: DOLLAR identifier
;

constant: STRING | INTEGER | FLOAT
;

// -------------------------------------- BUILDING BLOCK --------------------------------------

scopeInfo:                                  relationalIdentifier (DOT relationalIdentifier)?
;
databasePointer:                            BRACKET_OPEN qualifiedName BRACKET_CLOSE
;
relationalIdentifier:                       unquotedIdentifier | QUOTED_STRING
;




org.finos.legend.engine.shared.core.operational.errorManagement.EngineException: no viable alternative at input '{x,y|$x.firm_id==$y.firm_id&'

	at org.finos.legend.engine.language.pure.grammar.from.ParserErrorListener.syntaxError(ParserErrorListener.java:105)
	at org.antlr.v4.runtime.ProxyErrorListener.syntaxError(ProxyErrorListener.java:41)
	at org.antlr.v4.runtime.Parser.notifyErrorListeners(Parser.java:544)
	at org.antlr.v4.runtime.DefaultErrorStrategy.reportNoViableAlternative(DefaultErrorStrategy.java:310)
	at org.antlr.v4.runtime.DefaultErrorStrategy.reportError(DefaultErrorStrategy.java:136)
	at com.gs.alloy.lakehouse.runtime.grammar.antlr4.LakehouseMappingParserGrammar.functionOperationArgument(LakehouseMappingParserGrammar.java:922)
	at com.gs.alloy.lakehouse.runtime.grammar.antlr4.LakehouseMappingParserGrammar.functionExpressionParameters(LakehouseMappingParserGrammar.java:816)
	at com.gs.alloy.lakehouse.runtime.grammar.antlr4.LakehouseMappingParserGrammar.functionExpression(LakehouseMappingParserGrammar.java:745)
	at com.gs.alloy.lakehouse.runtime.grammar.antlr4.LakehouseMappingParserGrammar.operation(LakehouseMappingParserGrammar.java:658)
	at com.gs.alloy.lakehouse.runtime.grammar.antlr4.LakehouseMappingParserGrammar.propertyMapping(LakehouseMappingParserGrammar.java:548)
	at com.gs.alloy.lakehouse.runtime.grammar.antlr4.LakehouseMappingParserGrammar.lakehouseClassMapping(LakehouseMappingParserGrammar.java:365)
	at com.gs.alloy.lakehouse.runtime.model.grammar.parser.LakehouseRuntimeParserExtension.getMappingSectionParserInfo(LakehouseRuntimeParserExtension.java:86)
	at com.gs.alloy.lakehouse.runtime.model.grammar.parser.LakehouseRuntimeParserExtension.lambda$getExtraMappingElementParsers$0(LakehouseRuntimeParserExtension.java:103)
