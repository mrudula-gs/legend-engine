private static String renderRelationalOperationElement(RelationalOperationElement operation)
{
    if (operation instanceof DynaFunc)
    {
        DynaFunc func = (DynaFunc) operation;
        
        // Special handling for lambda functions
        if ("lambda".equals(func.funcName))
        {
            // For lambdas, we need to reconstruct the {x, y|...} syntax
            // This should be handled by the ElementWithLakeJoins serialization
            return renderLambdaFunction(func);
        }
        
        StringBuilder builder = new StringBuilder();
        builder.append(PureGrammarComposerUtility.convertIdentifier(func.funcName));
        builder.append("(");
        builder.append(ListIterate.collect(func.parameters, param -> renderRelationalOperationElement(param)).makeString(", "));
        builder.append(")");
        return builder.toString();
    }
    else if (operation instanceof IngestRelationColumn)
    {
        IngestRelationColumn column = (IngestRelationColumn) operation;
        StringBuilder builder = new StringBuilder();
        if (column.ingestAccessor != null && !column.ingestAccessor.path.isEmpty())
        {
            builder.append("[").append(column.ingestAccessor.path.get(0)).append("]").append(column.ingestAccessor.path.get(1));
        }
        if (column.column != null)
        {
            builder.append(".").append(column.column);
        }
        return builder.toString();
    }
    else if (operation instanceof Literal)
    {
        Literal literal = (Literal) operation;
        if (literal.value instanceof String)
        {
            return PureGrammarComposerUtility.convertString((String) literal.value, true);
        }
        return literal.value.toString();
    }
    else if (operation instanceof ElementWithLakeJoins)
    {
        ElementWithLakeJoins join = (ElementWithLakeJoins) operation;
        StringBuilder builder = new StringBuilder();
        
        // Serialize source1
        if (join.source1 != null && !join.source1.path.isEmpty())
        {
            builder.append("[").append(join.source1.path.get(0)).append("]").append(join.source1.path.get(1));
        }
        
        // Serialize join function
        builder.append("->join(");
        
        // Serialize source2
        if (join.source2 != null && !join.source2.path.isEmpty())
        {
            builder.append("[").append(join.source2.path.get(0)).append("]").append(join.source2.path.get(1));
        }
        
        // Serialize joinType
        if (join.joinType != null)
        {
            builder.append(", ").append(join.joinType);
        }
        
        // Serialize condition as lambda syntax
        if (join.condition != null && join.conditionParametersNames != null && !join.conditionParametersNames.isEmpty())
        {
            builder.append(", {");
            builder.append(String.join(", ", join.conditionParametersNames));
            builder.append("|");
            builder.append(renderLambdaBody(join.condition));
            builder.append("}");
        }
        
        builder.append(")");
        
        // Serialize projection
        if (join.relationalElement != null)
        {
            builder.append(" | ").append(renderRelationalOperationElement(join.relationalElement));
        }
        
        return builder.toString();
    }
    throw new IllegalStateException("Unsupported operation type: " + operation.getClass().getSimpleName());
}

private static String renderLambdaFunction(DynaFunc lambda)
{
    // This method handles standalone lambda functions
    // In the context of joins, lambdas should be handled by ElementWithLakeJoins
    StringBuilder builder = new StringBuilder();
    builder.append("lambda(");
    builder.append(ListIterate.collect(lambda.parameters, param -> renderRelationalOperationElement(param)).makeString(", "));
    builder.append(")");
    return builder.toString();
}

private static String renderLambdaBody(DynaFunc condition)
{
    // Render the lambda body (the condition part after the |)
    if ("equal".equals(condition.funcName) && condition.parameters.size() == 2)
    {
        String left = renderRelationalOperationElement(condition.parameters.get(0));
        String right = renderRelationalOperationElement(condition.parameters.get(1));
        return left + " == " + right;
    }
    // Add more condition types as needed (and, or, etc.)
    else if ("and".equals(condition.funcName) && condition.parameters.size() == 2)
    {
        String left = renderLambdaBody((DynaFunc) condition.parameters.get(0));
        String right = renderLambdaBody((DynaFunc) condition.parameters.get(1));
        return left + " && " + right;
    }
    else if ("or".equals(condition.funcName) && condition.parameters.size() == 2)
    {
        String left = renderLambdaBody((DynaFunc) condition.parameters.get(0));
        String right = renderLambdaBody((DynaFunc) condition.parameters.get(1));
        return left + " || " + right;
    }
    
    // Fallback to function syntax for complex conditions
    return renderRelationalOperationElement(condition);
}





// In visitPropertyMapping method, update this part:
if (ctx.operation().size() > 1) // Second operation is the projection
{
    ElementWithLakeJoins elementWithJoins = new ElementWithLakeJoins();
    elementWithJoins.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);

    // Extract join information if the operation is a join
    if (operation instanceof ElementWithLakeJoins)
    {
        ElementWithLakeJoins joinOp = (ElementWithLakeJoins) operation;
        elementWithJoins.source1 = joinOp.source1;
        elementWithJoins.source2 = joinOp.source2;
        elementWithJoins.joinType = joinOp.joinType;
        elementWithJoins.condition = joinOp.condition;
        elementWithJoins.conditionParametersNames = joinOp.conditionParametersNames;
        
        // For the projection, use the target table's ingest pointer (source2)
        elementWithJoins.relationalElement = visitOperation(ctx.operation(1), joinOp.source2);
    }
    else
    {
        // Handle non-join operations...
        elementWithJoins.relationalElement = visitOperation(ctx.operation(1), lakehouseClassMapping.ingestPtr);
    }
    
    propertyMapping.relationalOperation = elementWithJoins;
}





private RelationalOperationElement visitColumnOperation(LakehouseMappingParserGrammar.ColumnOperationContext ctx, Object ingestPtr)
{
    // ... existing code for tableAliasColumnOperation ...
    
    else if (ctx.variable() != null && ctx.relationalIdentifier() != null)
    {
        IngestRelationColumn column = new IngestRelationColumn();
        column.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
        column.ingestAccessor = new IngestRelationAccessor();
        column.ingestAccessor.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
        String paramName = PureGrammarParserUtility.fromIdentifier(ctx.variable().identifier());
        
        if (!paramName.equals("x") && !paramName.equals("y"))
        {
            throw new EngineException("Unsupported lambda parameter: $" + paramName, this.walkerSourceInformation.getSourceInformation(ctx), EngineErrorType.PARSER);
        }
        
        if (ingestPtr == null)
        {
            throw new EngineException("No IngestRelationAccessor provided for lambda parameter: $" + paramName, this.walkerSourceInformation.getSourceInformation(ctx), EngineErrorType.PARSER);
        }
        
        // Use the correct IngestRelationAccessor based on lambda parameter
        IngestRelationAccessor accessor;
        if (ingestPtr instanceof List && ((List<IngestRelationAccessor>) ingestPtr).size() >= 2)
        {
            List<IngestRelationAccessor> accessors = (List<IngestRelationAccessor>) ingestPtr;
            accessor = paramName.equals("x") ? accessors.get(0) : accessors.get(1);
        }
        else if (ingestPtr instanceof IngestRelationAccessor)
        {
            accessor = (IngestRelationAccessor) ingestPtr;
        }
        else
        {
            throw new EngineException("Invalid ingestPtr type for lambda parameter: $" + paramName, this.walkerSourceInformation.getSourceInformation(ctx), EngineErrorType.PARSER);
        }
        
        column.ingestAccessor.path = Lists.mutable.with(accessor.path.get(0), accessor.path.get(1));
        column.column = ctx.relationalIdentifier().QUOTED_STRING() != null
                ? PureGrammarParserUtility.fromGrammarString(ctx.relationalIdentifier().QUOTED_STRING().getText(), true)
                : PureGrammarParserUtility.fromIdentifier(ctx.relationalIdentifier().unquotedIdentifier());
        return column;
    }
    // ... rest of method ...
}
