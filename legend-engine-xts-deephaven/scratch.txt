package com.gs.alloy.lakehouse.runtime.model.grammar.parser;

import com.gs.alloy.lakehouse.ingest.api.accessor.protocol.IngestRelationAccessor;
import com.gs.alloy.lakehouse.protocol.pure.v1.model.packageableElement.mapping.IngestRelationColumn;
import com.gs.alloy.lakehouse.protocol.pure.v1.model.packageableElement.mapping.LakehouseClassMapping;
import com.gs.alloy.lakehouse.protocol.pure.v1.model.packageableElement.mapping.LakehousePropertyMapping;
import com.gs.alloy.lakehouse.runtime.grammar.antlr4.LakehouseMappingParserGrammar;
import org.antlr.v4.runtime.CharStream;
import org.eclipse.collections.api.factory.Lists;
import org.eclipse.collections.impl.utility.ListIterate;
import org.finos.legend.engine.language.pure.grammar.from.ParseTreeWalkerSourceInformation;
import org.finos.legend.engine.language.pure.grammar.from.PureGrammarParserContext;
import org.finos.legend.engine.language.pure.grammar.from.PureGrammarParserUtility;
import org.finos.legend.engine.language.pure.grammar.from.antlr4.mapping.MappingParserGrammar;
import org.finos.legend.engine.protocol.pure.v1.model.SourceInformation;
import org.finos.legend.engine.protocol.pure.v1.model.context.EngineErrorType;
import org.finos.legend.engine.protocol.pure.v1.model.packageableElement.mapping.PropertyPointer;
import org.finos.legend.engine.protocol.pure.v1.model.valueSpecification.ValueSpecification;
import org.finos.legend.engine.protocol.pure.v1.model.valueSpecification.raw.CString;
import org.finos.legend.engine.protocol.pure.v1.model.valueSpecification.raw.CFloat;
import org.finos.legend.engine.protocol.pure.v1.model.valueSpecification.raw.CInteger;
import org.finos.legend.engine.protocol.pure.v1.model.valueSpecification.raw.FunctionExpression;
import org.finos.legend.engine.protocol.pure.v1.model.valueSpecification.raw.Lambda;
import org.finos.legend.engine.protocol.pure.v1.model.valueSpecification.raw.Variable;
import org.finos.legend.engine.shared.core.operational.errorManagement.EngineException;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class LakehouseClassMappingParseTreeWalker
{
    private final CharStream input;
    private final ParseTreeWalkerSourceInformation walkerSourceInformation;
    private final PureGrammarParserContext parserContext;

    public LakehouseClassMappingParseTreeWalker(ParseTreeWalkerSourceInformation walkerSourceInformation, CharStream input, PureGrammarParserContext parserContext)
    {
        this.input = input;
        this.walkerSourceInformation = walkerSourceInformation;
        this.parserContext = parserContext;
    }

    private String visitDatabasePointer(LakehouseMappingParserGrammar.DatabasePointerContext ctx)
    {
        return ctx != null ? PureGrammarParserUtility.fromQualifiedName(ctx.qualifiedName().packagePath() == null ? Collections.emptyList() : ctx.qualifiedName().packagePath().identifier(), ctx.qualifiedName().identifier()) : null;
    }

    private String visitMappingScopeInfo(LakehouseMappingParserGrammar.MappingScopeInfoContext ctx)
    {
        return ctx != null ? PureGrammarParserUtility.fromIdentifier(ctx.unquotedIdentifier()) : null;
    }

    public void visitLakehouseClassMapping(LakehouseMappingParserGrammar.LakehouseClassMappingContext ctx, MappingParserGrammar.MappingElementContext classMappingContext, LakehouseClassMapping lakehouseClassMapping)
    {
        if (ctx.ingestSrc() != null)
        {
            IngestRelationAccessor tmp = new IngestRelationAccessor();
            tmp.path = Lists.mutable.with(visitDatabasePointer(ctx.ingestSrc().databasePointer()), ctx.ingestSrc().qualifiedName().getText());
            tmp.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx.ingestSrc());
            lakehouseClassMapping.ingestPtr = tmp;
        }
        else if (ctx.accessPointSrc() != null)
        {
            IngestRelationAccessor tmp = new IngestRelationAccessor();
            tmp.path = Lists.mutable.with(visitDatabasePointer(ctx.accessPointSrc().databasePointer()), ctx.accessPointSrc().qualifiedName().getText());
            tmp.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx.accessPointSrc());
            lakehouseClassMapping.ingestPtr = tmp;
        }
        lakehouseClassMapping.propertyMappings = ListIterate.collect(ctx.propertyMapping(), propertyMappingContext -> visitPropertyMapping(propertyMappingContext, classMappingContext, lakehouseClassMapping));
    }

    private LakehousePropertyMapping visitPropertyMapping(LakehouseMappingParserGrammar.PropertyMappingContext ctx, MappingParserGrammar.MappingElementContext classMappingContext, LakehouseClassMapping lakehouseClassMapping)
    {
        LakehousePropertyMapping propertyMapping = new LakehousePropertyMapping();
        propertyMapping.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
        PropertyPointer propertyPointer = new PropertyPointer();
        propertyPointer.property = PureGrammarParserUtility.fromIdentifier(ctx.qualifiedName());
        propertyPointer._class = lakehouseClassMapping._class;
        propertyPointer.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx.qualifiedName());
        propertyMapping.property = propertyPointer;
        propertyMapping.source = lakehouseClassMapping.id;

        ValueSpecification operation = visitOperation(ctx.operation(0), lakehouseClassMapping.ingestPtr);

        // Handle projection if present
        if (ctx.operation().size() > 1) // Second operation is the projection
        {
            FunctionExpression projectionFunc = new FunctionExpression();
            projectionFunc.functionName = "project";
            projectionFunc.parametersValues = new ArrayList<>();
            projectionFunc.parametersValues.add(operation);
            projectionFunc.parametersValues.add(visitOperation(ctx.operation(1), lakehouseClassMapping.ingestPtr));
            projectionFunc.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
            propertyMapping.operation = projectionFunc;
        }
        else
        {
            propertyMapping.operation = operation;
        }

        return propertyMapping;
    }

    private ValueSpecification visitOperation(LakehouseMappingParserGrammar.OperationContext ctx, IngestRelationAccessor ingestPtr)
    {
        if (ctx.booleanOperation() != null)
        {
            return visitBooleanOperation(ctx.booleanOperation(), ingestPtr);
        }
        else if (ctx.functionExpression() != null)
        {
            return visitFunctionExpression(ctx.functionExpression(), ingestPtr);
        }
        else if (ctx.expression() != null)
        {
            return visitExpression(ctx.expression(), ingestPtr);
        }
        throw new EngineException("Unsupported operation syntax", this.walkerSourceInformation.getSourceInformation(ctx), EngineErrorType.PARSER);
    }

    private ValueSpecification visitBooleanOperation(LakehouseMappingParserGrammar.BooleanOperationContext ctx, IngestRelationAccessor ingestPtr)
    {
        ValueSpecification left = visitAtomicExpression(ctx.atomicOperation(), ingestPtr);
        if (ctx.booleanOperationRight() != null)
        {
            FunctionExpression operation = new FunctionExpression();
            operation.functionName = ctx.booleanOperationRight().booleanOperator().AND() != null ? "and" : "or";
            operation.parametersValues = new ArrayList<>();
            operation.parametersValues.add(left);
            operation.parametersValues.add(visitOperation(ctx.booleanOperationRight().operation(), ingestPtr));
            operation.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
            return operation;
        }
        return left;
    }

    private ValueSpecification visitFunctionExpression(LakehouseMappingParserGrammar.FunctionExpressionContext ctx, IngestRelationAccessor ingestPtr)
    {
        FunctionExpression func = new FunctionExpression();
        func.functionName = PureGrammarParserUtility.fromIdentifier(ctx.identifier(1)); // e.g., "join", "toUpper"
        func.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
        func.parametersValues = new ArrayList<>();

        // Parse source relation: [test::ingest::PersonIngest]Person
        IngestRelationColumn sourceColumn = new IngestRelationColumn();
        sourceColumn.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx.databasePointer());
        sourceColumn.ingestAccessor = new IngestRelationAccessor();
        sourceColumn.ingestAccessor.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx.databasePointer());
        String sourceDb = visitDatabasePointer(ctx.databasePointer());
        String sourceTable = PureGrammarParserUtility.fromIdentifier(ctx.identifier(0));
        sourceColumn.ingestAccessor.path = Lists.mutable.with(sourceDb, sourceTable);

        // Add source column as an InstanceValue
        org.finos.legend.engine.protocol.pure.v1.model.valueSpecification.raw.InstanceValue sourceValue = new org.finos.legend.engine.protocol.pure.v1.model.valueSpecification.raw.InstanceValue();
        sourceValue.sourceInformation = sourceColumn.sourceInformation;
        sourceValue.values = Collections.singletonList(sourceColumn);
        func.parametersValues.add(sourceValue);

        // Parse function parameters
        if (ctx.functionExpressionParameters() != null)
        {
            LakehouseMappingParserGrammar.FunctionExpressionParametersContext paramsCtx = ctx.functionExpressionParameters();
            List<IngestRelationAccessor> lambdaAccessors = new ArrayList<>();
            if (func.functionName.equals("join") && paramsCtx.combinedExpression().size() >= 3)
            {
                // For join, store source and target accessors for lambda parameters
                ValueSpecification targetArg = visitCombinedExpression(paramsCtx.combinedExpression(0), ingestPtr);
                if (targetArg instanceof org.finos.legend.engine.protocol.pure.v1.model.valueSpecification.raw.InstanceValue &&
                    ((org.finos.legend.engine.protocol.pure.v1.model.valueSpecification.raw.InstanceValue) targetArg).values.get(0) instanceof IngestRelationColumn)
                {
                    IngestRelationColumn targetColumn = (IngestRelationColumn) ((org.finos.legend.engine.protocol.pure.v1.model.valueSpecification.raw.InstanceValue) targetArg).values.get(0);
                    lambdaAccessors.add(sourceColumn.ingestAccessor); // x
                    lambdaAccessors.add(targetColumn.ingestAccessor); // y
                }
                func.parametersValues.add(targetArg);
                func.parametersValues.add(visitCombinedExpression(paramsCtx.combinedExpression(1), ingestPtr)); // JoinKind.INNER
                func.parametersValues.add(visitCombinedExpression(paramsCtx.combinedExpression(2), lambdaAccessors)); // Lambda
            }
            else
            {
                // For non-join functions (e.g., toUpper), use default ingestPtr
                func.parametersValues.addAll(ListIterate.collect(paramsCtx.combinedExpression(), argCtx -> visitCombinedExpression(argCtx, ingestPtr)));
            }
        }

        return func;
    }

    private ValueSpecification visitExpression(LakehouseMappingParserGrammar.ExpressionContext ctx, IngestRelationAccessor ingestPtr)
    {
        ValueSpecification left = visitAtomicExpression(ctx.atomicExpression(), ingestPtr);
        if (ctx.equalNotEqual() != null)
        {
            FunctionExpression operation = new FunctionExpression();
            operation.functionName = ctx.equalNotEqual().TEST_EQUAL() != null ? "equal" : "notEqual";
            operation.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
            operation.parametersValues = new ArrayList<>();
            operation.parametersValues.add(left);
            operation.parametersValues.add(visitAtomicExpression(ctx.equalNotEqual().atomicExpression(), ingestPtr));
            return operation;
        }
        return left;
    }

    private ValueSpecification visitAtomicExpression(LakehouseMappingParserGrammar.AtomicExpressionContext ctx, IngestRelationAccessor ingestPtr)
    {
        if (ctx.columnOperation() != null)
        {
            IngestRelationColumn column = (IngestRelationColumn) visitColumnOperation(ctx.columnOperation(), ingestPtr);
            org.finos.legend.engine.protocol.pure.v1.model.valueSpecification.raw.InstanceValue instance = new org.finos.legend.engine.protocol.pure.v1.model.valueSpecification.raw.InstanceValue();
            instance.sourceInformation = column.sourceInformation;
            instance.values = Collections.singletonList(column);
            return instance;
        }
        else if (ctx.constant() != null)
        {
            if (ctx.constant().STRING() != null)
            {
                CString constant = new CString();
                constant.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
                constant.value = PureGrammarParserUtility.fromGrammarString(ctx.constant().STRING().getText(), true);
                return constant;
            }
            else if (ctx.constant().INTEGER() != null)
            {
                CInteger constant = new CInteger();
                constant.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
                constant.value = Long.parseLong(ctx.constant().INTEGER().getText());
                return constant;
            }
            else if (ctx.constant().FLOAT() != null)
            {
                CFloat constant = new CFloat();
                constant.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
                constant.value = Double.parseDouble(ctx.constant().FLOAT().getText());
                return constant;
            }
            else
            {
                throw new EngineException("Unsupported constant syntax", this.walkerSourceInformation.getSourceInformation(ctx), EngineErrorType.PARSER);
            }
        }
        else if (ctx.anyLambda() != null)
        {
            return visitAnyLambda(ctx.anyLambda(), ingestPtr);
        }
        else if (ctx.operation() != null)
        {
            return visitOperation(ctx.operation(), ingestPtr);
        }
        throw new EngineException("Unsupported atomic expression syntax", this.walkerSourceInformation.getSourceInformation(ctx), EngineErrorType.PARSER);
    }

    private ValueSpecification visitAnyLambda(LakehouseMappingParserGrammar.AnyLambdaContext ctx, IngestRelationAccessor ingestPtr)
    {
        Lambda lambda = new Lambda();
        lambda.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
        lambda.parameters = new ArrayList<>();
        if (ctx.lambdaParam() != null)
        {
            for (LakehouseMappingParserGrammar.LambdaParamContext paramCtx : ctx.lambdaParam())
            {
                Variable param = new Variable();
                param.name = PureGrammarParserUtility.fromIdentifier(paramCtx.identifier());
                param.sourceInformation = this.walkerSourceInformation.getSourceInformation(paramCtx);
                lambda.parameters.add(param);
            }
        }
        if (ctx.operation() != null)
        {
            lambda.body = Collections.singletonList(visitOperation(ctx.operation(), ingestPtr));
        }
        return lambda;
    }

    private ValueSpecification visitCombinedExpression(LakehouseMappingParserGrammar.CombinedExpressionContext ctx, Object ingestPtr)
    {
        IngestRelationAccessor accessor = ingestPtr instanceof IngestRelationAccessor ? (IngestRelationAccessor) ingestPtr : (ingestPtr instanceof List ? ((List<IngestRelationAccessor>) ingestPtr).get(0) : null);
        if (ctx.expression() != null)
        {
            ValueSpecification expr = visitExpression(ctx.expression(), accessor);
            if (ctx.expressionPart() != null && !ctx.expressionPart().isEmpty())
            {
                FunctionExpression combined = new FunctionExpression();
                combined.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
                combined.parametersValues = new ArrayList<>();
                combined.parametersValues.add(expr);
                for (LakehouseMappingParserGrammar.ExpressionPartContext partCtx : ctx.expressionPart())
                {
                    if (partCtx.booleanPart() != null)
                    {
                        FunctionExpression booleanPart = new FunctionExpression();
                        booleanPart.sourceInformation = this.walkerSourceInformation.getSourceInformation(partCtx);
                        booleanPart.functionName = partCtx.booleanPart().AND() != null ? "and" : "or";
                        booleanPart.parametersValues = new ArrayList<>();
                        booleanPart.parametersValues.add(combined.parametersValues.get(combined.parametersValues.size() - 1));
                        booleanPart.parametersValues.add(visitExpression(partCtx.booleanPart().expression(), accessor));
                        combined.parametersValues.set(combined.parametersValues.size() - 1, booleanPart);
                    }
                    else if (partCtx.arithmeticPart() != null)
                    {
                        FunctionExpression arithmeticPart = new FunctionExpression();
                        arithmeticPart.sourceInformation = this.walkerSourceInformation.getSourceInformation(partCtx);
                        if (partCtx.arithmeticPart().PLUS() != null)
                        {
                            arithmeticPart.functionName = "plus";
                        }
                        else if (partCtx.arithmeticPart().STAR() != null)
                        {
                            arithmeticPart.functionName = "times";
                        }
                        else if (partCtx.arithmeticPart().MINUS() != null)
                        {
                            arithmeticPart.functionName = "minus";
                        }
                        else if (partCtx.arithmeticPart().DIVIDE() != null)
                        {
                            arithmeticPart.functionName = "divide";
                        }
                        else if (partCtx.arithmeticPart().LESS_THAN() != null)
                        {
                            arithmeticPart.functionName = "lessThan";
                        }
                        else if (partCtx.arithmeticPart().LESS_OR_EQUAL() != null)
                        {
                            arithmeticPart.functionName = "lessThanEqual";
                        }
                        else if (partCtx.arithmeticPart().GREATER_THAN() != null)
                        {
                            arithmeticPart.functionName = "greaterThan";
                        }
                        else if (partCtx.arithmeticPart().GREATER_OR_EQUAL() != null)
                        {
                            arithmeticPart.functionName = "greaterThanEqual";
                        }
                        arithmeticPart.parametersValues = new ArrayList<>();
                        arithmeticPart.parametersValues.add(combined.parametersValues.get(combined.parametersValues.size() - 1));
                        arithmeticPart.parametersValues.add(visitExpression(partCtx.arithmeticPart().expression(), accessor));
                        combined.parametersValues.set(combined.parametersValues.size() - 1, arithmeticPart);
                    }
                }
                return combined;
            }
            return expr;
        }
        throw new EngineException("Unsupported combined expression syntax", this.walkerSourceInformation.getSourceInformation(ctx), EngineErrorType.PARSER);
    }

    private ValueSpecification visitColumnOperation(LakehouseMappingParserGrammar.ColumnOperationContext ctx, IngestRelationAccessor ingestPtr)
    {
        if (ctx.tableAliasColumnOperation() != null)
        {
            return visitTableAliasColumnOperation(ctx.tableAliasColumnOperation(), ingestPtr);
        }
        else if (ctx.variable() != null && ctx.relationalIdentifier() != null)
        {
            IngestRelationColumn column = new IngestRelationColumn();
            column.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
            column.ingestAccessor = new IngestRelationAccessor();
            column.ingestAccessor.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
            String paramName = PureGrammarParserUtility.fromIdentifier(ctx.variable().identifier());
            if (!paramName.equals("x") && !paramName.equals("y"))
            {
                throw new EngineException("Unsupported lambda parameter: $" + paramName, this.walkerSourceInformation.getSourceInformation(ctx), EngineErrorType.PARSER);
            }
            if (ingestPtr == null)
            {
                throw new EngineException("No IngestRelationAccessor provided for lambda parameter: $" + paramName, this.walkerSourceInformation.getSourceInformation(ctx), EngineErrorType.PARSER);
            }
            column.ingestAccessor.path = Lists.mutable.with(ingestPtr.path.get(0), ingestPtr.path.get(1));
            column.column = ctx.relationalIdentifier().QUOTED_STRING() != null
                    ? PureGrammarParserUtility.fromGrammarString(ctx.relationalIdentifier().QUOTED_STRING().getText(), true)
                    : PureGrammarParserUtility.fromIdentifier(ctx.relationalIdentifier().unquotedIdentifier());
            org.finos.legend.engine.protocol.pure.v1.model.valueSpecification.raw.InstanceValue instance = new org.finos.legend.engine.protocol.pure.v1.model.valueSpecification.raw.InstanceValue();
            instance.sourceInformation = column.sourceInformation;
            instance.values = Collections.singletonList(column);
            return instance;
        }
        throw new EngineException("Unsupported column operation syntax", this.walkerSourceInformation.getSourceInformation(ctx), EngineErrorType.PARSER);
    }

    private ValueSpecification visitTableAliasColumnOperation(LakehouseMappingParserGrammar.TableAliasColumnOperationContext ctx, IngestRelationAccessor ingestPtr)
    {
        if (ctx.tableAliasColumnOperationWithTarget() != null)
        {
            return visitTableAliasColumnOperationWithTarget(ctx.tableAliasColumnOperationWithTarget(), ingestPtr);
        }
        else if (ctx.tableAliasColumnOperationWithScopeInfo() != null)
        {
            return visitTableAliasColumnOperationWithScopeInfo(ctx.tableAliasColumnOperationWithScopeInfo(), ingestPtr);
        }
        throw new EngineException("Unsupported column operation syntax", this.walkerSourceInformation.getSourceInformation(ctx), EngineErrorType.PARSER);
    }

    private ValueSpecification visitTableAliasColumnOperationWithTarget(LakehouseMappingParserGrammar.TableAliasColumnOperationWithTargetContext ctx, IngestRelationAccessor ingestPtr)
    {
        IngestRelationColumn column = new IngestRelationColumn();
        column.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
        column.ingestAccessor = new IngestRelationAccessor();
        column.ingestAccessor.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
        String databasePath = ingestPtr != null ? ingestPtr.path.get(0) : null;
        String tableName = ctx.TARGET() != null ? ctx.TARGET().getText() : null;
        if (tableName == null)
        {
            throw new EngineException("Table name (TARGET) is required in column operation", this.walkerSourceInformation.getSourceInformation(ctx), EngineErrorType.PARSER);
        }
        column.ingestAccessor.path = Lists.mutable.with(databasePath, tableName);
        column.column = ctx.relationalIdentifier().QUOTED_STRING() != null
                ? PureGrammarParserUtility.fromGrammarString(ctx.relationalIdentifier().QUOTED_STRING().getText(), true)
                : PureGrammarParserUtility.fromIdentifier(ctx.relationalIdentifier().unquotedIdentifier());
        org.finos.legend.engine.protocol.pure.v1.model.valueSpecification.raw.InstanceValue instance = new org.finos.legend.engine.protocol.pure.v1.model.valueSpecification.raw.InstanceValue();
        instance.sourceInformation = column.sourceInformation;
        instance.values = Collections.singletonList(column);
        return instance;
    }

    private ValueSpecification visitTableAliasColumnOperationWithScopeInfo(LakehouseMappingParserGrammar.TableAliasColumnOperationWithScopeInfoContext ctx, IngestRelationAccessor ingestPtr)
    {
        IngestRelationColumn column = new IngestRelationColumn();
        column.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
        column.ingestAccessor = new IngestRelationAccessor();
        column.ingestAccessor.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
        String databasePath = ingestPtr != null ? ingestPtr.path.get(0) : null;
        String tableName = ctx.relationalIdentifier().QUOTED_STRING() != null
                ? PureGrammarParserUtility.fromGrammarString(ctx.relationalIdentifier().QUOTED_STRING().getText(), true)
                : PureGrammarParserUtility.fromIdentifier(ctx.relationalIdentifier().unquotedIdentifier());
        column.ingestAccessor.path = Lists.mutable.with(databasePath, tableName);
        if (ctx.scopeInfo() != null && ctx.scopeInfo().relationalIdentifier().size() > 0)
        {
            column.column = ctx.scopeInfo().relationalIdentifier(0).QUOTED_STRING() != null
                    ? PureGrammarParserUtility.fromGrammarString(ctx.scopeInfo().relationalIdentifier(0).QUOTED_STRING().getText(), true)
                    : PureGrammarParserUtility.fromIdentifier(ctx.scopeInfo().relationalIdentifier(0).unquotedIdentifier());
        }
        org.finos.legend.engine.protocol.pure.v1.model.valueSpecification.raw.InstanceValue instance = new org.finos.legend.engine.protocol.pure.v1.model.valueSpecification.raw.InstanceValue();
        instance.sourceInformation = column.sourceInformation;
        instance.values = Collections.singletonList(column);
        return instance;
    }
}
