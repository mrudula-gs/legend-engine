parser grammar LakehouseMappingParserGrammar;

import RelationalParserGrammar;

options
{
    tokenVocab = LakehouseMappingLexerGrammar;
}

// -------------------------------------- IDENTIFIER --------------------------------------

unquotedIdentifier:                         VALID_STRING
                                            | ALL | LET | ALL_VERSIONS | ALL_VERSIONS_IN_RANGE
                                            | TO_BYTES_FUNCTION
                                            | INGEST_SOURCE_CMD | ACCESS_POINT_SOURCE_CMD
;

identifier:                                 unquotedIdentifier | STRING
;

// -------------------------------------- LAKEHOUSE MAPPING DEFINITION --------------------------------------

lakehouseClassMapping:                      (ingestSrc | accessPointSrc)
                                                (propertyMapping (COMMA propertyMapping)*)?
                                            EOF
;
ingestSrc:                                  INGEST_SOURCE_CMD databasePointer qualifiedName
;
accessPointSrc:                             ACCESS_POINT_SOURCE_CMD databasePointer qualifiedName
;
propertyMapping:                            qualifiedName STAR? COLON operation (PIPE operation)?
;
mappingScopeInfo:                           unquotedIdentifier
;

// -------------------------------------- OPERATION --------------------------------------
operation: booleanOperation
         | functionExpression
         | expression
;

functionExpression: databasePointer identifier ARROW identifier functionExpressionParameters
;

functionExpressionParameters: PAREN_OPEN (functionOperationArgument (COMMA functionOperationArgument)*)? PAREN_CLOSE
;

functionOperationArgument:  databasePointer identifier | operation | anyLambda | qualifiedName
;

anyLambda: BRACE_OPEN (lambdaParam (COMMA lambdaParam)*)? PIPE operation BRACE_CLOSE
;

lambdaParam: identifier
;

expression: atomicExpression (equalNotEqual)?
;

equalNotEqual: (TEST_EQUAL | TEST_NOT_EQUAL) atomicExpression
;

atomicExpression: columnOperation
                | constant
                | anyLambda
                | PAREN_OPEN operation PAREN_CLOSE
;

columnOperation: databasePointer? tableAliasColumnOperation
               | variable DOT relationalIdentifier
;

variable: DOLLAR identifier
;

constant: STRING | INTEGER | FLOAT
;

// -------------------------------------- BUILDING BLOCK --------------------------------------

scopeInfo:                                  relationalIdentifier (DOT relationalIdentifier)?
;
databasePointer:                            BRACKET_OPEN qualifiedName BRACKET_CLOSE
;
relationalIdentifier:                       unquotedIdentifier | QUOTED_STRING
;



parser grammar RelationalParserGrammar;

import CoreParserGrammar;

options
{
    tokenVocab = RelationalLexerGrammar;
}


// -------------------------------------- IDENTIFIER --------------------------------------

unquotedIdentifier:                         VALID_STRING
                                            | DATABASE | INCLUDE
                                            | SCHEMA | TABLE | VIEW | JOIN | FILTER | MULTIGRAIN_FILTER
                                            | AND | OR
                                            | MILESTONING | BUSINESS_MILESTONING | BUSINESS_MILESTONING_FROM | BUSINESS_MILESTONING_THRU
                                            | OUT_IS_INCLUSIVE | THRU_IS_INCLUSIVE | INFINITY_DATE | BUS_SNAPSHOT_DATE
                                            | PROCESSING_MILESTONING | PROCESSING_MILESTONING_IN | PROCESSING_MILESTONING_OUT | PROCESSING_SNAPSHOT_DATE
                                            | SCOPE | ENUMERATION_MAPPING | ASSOCIATION_MAPPING | OTHERWISE | INLINE | BINDING | TABULAR_FUNC
;

identifier:                                 unquotedIdentifier | STRING
;

// -------------------------------------- DEFINITION --------------------------------------

definition:                                 (database)*
                                            EOF
;
database:                                   DATABASE stereotypes? taggedValues? qualifiedName
                                                PAREN_OPEN
                                                    include*
                                                    (
                                                        schema
                                                        | table
                                                        | view
                                                        | join
                                                        | tabularFunction
                                                        | filter
                                                        | multiGrainFilter
                                                    )*
                                                PAREN_CLOSE
;
include:                                    INCLUDE qualifiedName
;

// -------------------------------------- STEREOTYPE --------------------------------------

stereotypes:                        LESS_THAN LESS_THAN stereotype (COMMA stereotype)* GREATER_THAN GREATER_THAN;

stereotype:                         qualifiedName DOT identifier;

taggedValues:                                   BRACE_OPEN taggedValue (COMMA taggedValue)* BRACE_CLOSE
;
taggedValue:                                    qualifiedName DOT identifier EQUAL STRING
;

// -------------------------------------- SCHEMA & TABLE --------------------------------------

schema:                                     SCHEMA stereotypes? taggedValues? schemaIdentifier
                                                PAREN_OPEN
                                                    (
                                                        table
                                                        | view
                                                        | tabularFunction
                                                    )*
                                                PAREN_CLOSE
;
table:                                      TABLE stereotypes? taggedValues? relationalIdentifier
                                                PAREN_OPEN
                                                    milestoneSpec?
                                                    (columnDefinition (COMMA columnDefinition)*)?
                                                PAREN_CLOSE
;
columnDefinition:                           relationalIdentifier stereotypes? taggedValues? identifier (PAREN_OPEN INTEGER (COMMA INTEGER)? PAREN_CLOSE)? (PRIMARY_KEY | NOT_NULL)?
;

// -------------------------------------- MILESTONING --------------------------------------

milestoneSpec:                              MILESTONING
                                                PAREN_OPEN
                                                    (milestoning (COMMA milestoning)*)?
                                                PAREN_CLOSE
;
milestoning:                                milestoningType
                                                PAREN_OPEN
                                                    milestoningSpecification
                                                PAREN_CLOSE
;
milestoningType:                            identifier
;
milestoningSpecification:                   (relationalIdentifier | COMMA | BOOLEAN | DATE | EQUAL)*
;
businessMilestoning:                        BUSINESS_MILESTONING
                                                PAREN_OPEN
                                                    (
                                                        businessMilestoningFromThru
                                                        | businessSnapshotDate
                                                    )
                                                PAREN_CLOSE
;
businessMilestoningFromThru:                BUSINESS_MILESTONING_FROM EQUAL identifier COMMA
                                            BUSINESS_MILESTONING_THRU EQUAL identifier
                                            (COMMA THRU_IS_INCLUSIVE EQUAL BOOLEAN)?
                                            (COMMA INFINITY_DATE EQUAL DATE)?
;
businessSnapshotDate:                       BUS_SNAPSHOT_DATE EQUAL identifier
;
processingMilestoning:                      PROCESSING_MILESTONING
                                                PAREN_OPEN
                                                    (
                                                        processingMilestoningInOut
                                                        | processingSnapshotDate
                                                    )
                                                PAREN_CLOSE
;
processingMilestoningInOut:                 PROCESSING_MILESTONING_IN EQUAL identifier COMMA
                                            PROCESSING_MILESTONING_OUT EQUAL identifier
                                            (COMMA OUT_IS_INCLUSIVE EQUAL BOOLEAN)?
                                            (COMMA INFINITY_DATE EQUAL DATE)?
;
processingSnapshotDate:                     PROCESSING_SNAPSHOT_DATE EQUAL identifier
;
// -------------------------------------- VIEW --------------------------------------

view:                                       VIEW stereotypes? taggedValues?  relationalIdentifier
                                                PAREN_OPEN
                                                    (viewFilterMapping)?
                                                    (viewGroupBy)?
                                                    (DISTINCT_CMD)?
                                                    (viewColumnMapping (COMMA viewColumnMapping)*)?
                                                PAREN_CLOSE
;
viewFilterMapping:                          FILTER_CMD (viewFilterMappingJoin | databasePointer)? identifier
;
viewFilterMappingJoin:                      databasePointer joinSequence PIPE databasePointer
;
viewGroupBy:                                GROUP_BY_CMD
                                                PAREN_OPEN
                                                    (operation (COMMA operation)*)?
                                                PAREN_CLOSE
;
viewColumnMapping:                          identifier (BRACKET_OPEN identifier BRACKET_CLOSE)? COLON operation PRIMARY_KEY?
;

// -------------------------------------- TABULAR FUNCTION --------------------------------------
tabularFunction:                               TABULAR_FUNC relationalIdentifier
                                                PAREN_OPEN
                                                    (columnDefinition (COMMA columnDefinition)*)?
                                                PAREN_CLOSE
;


// -------------------------------------- FILTER & JOIN --------------------------------------

filter:                                     FILTER identifier PAREN_OPEN operation PAREN_CLOSE
;
multiGrainFilter:                           MULTIGRAIN_FILTER identifier PAREN_OPEN operation PAREN_CLOSE
;
join:                                       JOIN identifier PAREN_OPEN operation PAREN_CLOSE
;

// -------------------------------------- OPERATIONS --------------------------------------

// NOTE: we have the `...Right` parser rule to avoid mutually left-recursive rules. For example, the rule
// `booleanOperation: operation booleanOperator operation` will cause ANTLR to throw error
// See https://github.com/antlr/antlr4/blob/master/doc/left-recursion.md
//
// Also note that we split the rule `operation` because in `joinOperation` we cannot directly use `joinOperation` as the operation
//
// IMPORTANT: Notice the way we construct `booleanOperation`, and `atomicOperation` which
// forms a hierarchy/precedence. The gist of this is:
//  - The more deeply nested the parser rule, the higher the precedence it is
//  - The higher precedence rule should use only token of precedence equals or higher than itself
//    (i.e. `atomicOperation` should not use `booleanOperation` in its parser definition)
// See https://stackoverflow.com/questions/1451728/antlr-operator-precedence

operation:                                  booleanOperation
                                            | joinOperation
;
booleanOperation:                           atomicOperation booleanOperationRight?
;
booleanOperationRight:                      booleanOperator operation
;
booleanOperator:                            AND | OR
;
atomicOperation:                            (
                                                groupOperation
                                                | ( databasePointer? functionOperation )
                                                | columnOperation
                                                | joinOperation
                                                | constant
                                            )
                                            atomicOperationRight?
;
atomicOperationRight:                       (atomicOperator atomicOperation) | atomicSelfOperator
;
atomicOperator:                             EQUAL | TEST_NOT_EQUAL | NOT_EQUAL | GREATER_THAN | LESS_THAN | GREATER_OR_EQUAL | LESS_OR_EQUAL
;
atomicSelfOperator:                         IS_NULL | IS_NOT_NULL
;
groupOperation:                             PAREN_OPEN operation PAREN_CLOSE
;
constant:                                   STRING | INTEGER | FLOAT
;
functionOperation:                          identifier PAREN_OPEN (functionOperationArgument (COMMA functionOperationArgument)*)? PAREN_CLOSE
;
functionOperationArgument:                  operation | functionOperationArgumentArray
;
functionOperationArgumentArray:             BRACKET_OPEN (functionOperationArgument (COMMA functionOperationArgument)*)? BRACKET_CLOSE
;
columnOperation:                            databasePointer? tableAliasColumnOperation
;
tableAliasColumnOperation:                  tableAliasColumnOperationWithTarget | tableAliasColumnOperationWithScopeInfo
;
tableAliasColumnOperationWithTarget:        TARGET DOT relationalIdentifier
;
tableAliasColumnOperationWithScopeInfo:     relationalIdentifier (DOT scopeInfo)?
;
joinOperation:                              databasePointer? joinSequence (PIPE (booleanOperation | tableAliasColumnOperation))?
;
joinSequence:                               (PAREN_OPEN identifier PAREN_CLOSE)? joinPointer (GREATER_THAN joinPointerFull)*
;
joinPointer:                                AT identifier
;
joinPointerFull:                            (PAREN_OPEN identifier PAREN_CLOSE)? databasePointer? joinPointer
;


// -------------------------------------- RELATIONAL MAPPING --------------------------------------

// NOTE: Order must be preserved here as we want the associationMapping rule to be mapped as an associationMapping
// not as an embedded property mapping
mapping:                                    associationMapping | classMapping
;
associationMapping:                         ASSOCIATION_MAPPING
                                                PAREN_OPEN
                                                    propertyMapping (COMMA propertyMapping)*
                                                PAREN_CLOSE
                                                EOF
;
classMapping:                               mappingFilter?
                                            DISTINCT_CMD?
                                            mappingGroupBy?
                                            mappingPrimaryKey?
                                            mappingMainTable?
                                            (propertyMapping (COMMA propertyMapping)*)?
                                            EOF
;
mappingFilter:                              FILTER_CMD databasePointer (joinSequence PIPE databasePointer)? identifier
;
mappingGroupBy:                             GROUP_BY_CMD
                                                PAREN_OPEN
                                                    (operation (COMMA operation)*)?
                                                PAREN_CLOSE
;
mappingPrimaryKey:                          PRIMARY_KEY_CMD
                                                PAREN_OPEN
                                                    (operation (COMMA operation)*)?
                                                PAREN_CLOSE
;
mappingMainTable:                           MAIN_TABLE_CMD databasePointer mappingScopeInfo
;
mappingScopeInfo:                           relationalIdentifier (DOT scopeInfo)?
;


// -------------------------------------- PROPERTY MAPPING --------------------------------------

propertyMapping:                            singlePropertyMapping | propertyMappingWithScope
;
propertyMappingWithScope:                   SCOPE PAREN_OPEN databasePointer mappingScopeInfo? PAREN_CLOSE
                                                PAREN_OPEN
                                                    singlePropertyMapping (COMMA singlePropertyMapping)*
                                                PAREN_CLOSE
;
singlePropertyMapping:                      singlePropertyMappingWithPlus | singlePropertyMappingWithoutPlus
;
singlePropertyMappingWithPlus:              PLUS identifier localMappingProperty relationalPropertyMapping
;
singlePropertyMappingWithoutPlus:           identifier sourceAndTargetMappingId?
                                            (
                                                relationalPropertyMapping
                                                | embeddedPropertyMapping
                                                | inlineEmbeddedPropertyMapping
                                            )
;
sourceAndTargetMappingId:                   BRACKET_OPEN sourceId (COMMA targetId)? BRACKET_CLOSE
;
sourceId:                                   identifier
;
targetId:                                   identifier
;
relationalPropertyMapping:                  COLON (transformer)? operation
;
transformer:                                enumTransformer | bindingTransformer
;
enumTransformer:                            ENUMERATION_MAPPING identifier COLON
;
bindingTransformer:                         BINDING qualifiedName COLON
;


// -------------------------------------- LOCAL MAPPING PROPERTY --------------------------------------

localMappingProperty:                       COLON qualifiedName BRACKET_OPEN (localMappingPropertyFromMultiplicity DOT_DOT)? localMappingPropertyToMultiplicity BRACKET_CLOSE
;
localMappingPropertyFromMultiplicity:       INTEGER | STAR
;
localMappingPropertyToMultiplicity:         INTEGER | STAR
;


// -------------------------------------- EMBEDDED PROPERTY MAPPING --------------------------------------

embeddedPropertyMapping:                    PAREN_OPEN
                                            (
                                                mappingPrimaryKey?
                                                singlePropertyMapping (COMMA singlePropertyMapping)*
                                            )?
                                            PAREN_CLOSE (otherwiseEmbeddedPropertyMapping)?
;
inlineEmbeddedPropertyMapping:              PAREN_OPEN PAREN_CLOSE INLINE BRACKET_OPEN identifier BRACKET_CLOSE
;
otherwiseEmbeddedPropertyMapping:           OTHERWISE PAREN_OPEN otherwisePropertyMapping PAREN_CLOSE
;
otherwisePropertyMapping:                   BRACKET_OPEN identifier BRACKET_CLOSE COLON databasePointer? joinSequence
;


// -------------------------------------- BUILDING BLOCK --------------------------------------

scopeInfo:                                  relationalIdentifier (DOT relationalIdentifier)?
;
databasePointer:                            BRACKET_OPEN qualifiedName BRACKET_CLOSE
;
relationalIdentifier:                       unquotedIdentifier | QUOTED_STRING
;
// Should be the same as relationalIdentifier, but it currently breaks some projects
schemaIdentifier:                           identifier | QUOTED_STRING
;







parser grammar M3ParserGrammar;

import CoreParserGrammar;


// -------------------------------------- IDENTIFIER --------------------------------------

identifier:                                     VALID_STRING | STRING
                                                | ALL | LET | ALL_VERSIONS | ALL_VERSIONS_IN_RANGE
                                                | TO_BYTES_FUNCTION
;

// -------------------------------------- EXPRESSION & VALUE SPECIFICATION --------------------------------------

nonArrowOrEqualExpression :
                                                (
                                                    atomicExpression
                                                    | notExpression
                                                    | signedExpression
                                                    | expressionsArray
                                                    | (PAREN_OPEN combinedExpression PAREN_CLOSE)
                                                )
;

expression:                                     (
                                                    nonArrowOrEqualExpression
                                                    (
                                                        (propertyOrFunctionExpression)*
                                                        (equalNotEqual)?
                                                    )
                                                )
;


instance:                                       NEW_SYMBOL qualifiedName (LESS_THAN typeArguments? (PIPE multiplicityArguments)? GREATER_THAN)? identifier?
                                                (FILE_NAME COLON INTEGER COMMA INTEGER COMMA INTEGER COMMA INTEGER COMMA INTEGER COMMA INTEGER FILE_NAME_END)? (AT qualifiedName)?
                                                    PAREN_OPEN
                                                        (instancePropertyAssignment (COMMA instancePropertyAssignment)*)?
                                                    PAREN_CLOSE
;
unitInstance:                                   unitInstanceLiteral unitName
;
unitName:                                       qualifiedName TILDE identifier
;
instancePropertyAssignment:                     identifier EQUAL instanceRightSide
;
instanceRightSide:                              instanceAtomicRightSideScalar | instanceAtomicRightSideVector
;
instanceAtomicRightSideScalar:                  instanceAtomicRightSide
;
instanceAtomicRightSideVector:                  BRACKET_OPEN (instanceAtomicRightSide (COMMA instanceAtomicRightSide)* )? BRACKET_CLOSE
;
instanceAtomicRightSide:                        instanceLiteral
                                                | LATEST_DATE
                                                | instance
                                                | qualifiedName
                                                | enumReference
                                                | stereotypeReference
                                                | tagReference
                                                | identifier
;
enumReference:                                  qualifiedName  DOT identifier
;
stereotypeReference:                            qualifiedName AT identifier
;
tagReference:                                   qualifiedName PERCENT identifier
;
propertyReturnType:                             type multiplicity
;
codeBlock:                                      programLine (SEMI_COLON (programLine SEMI_COLON)*)?
;
programLine:                                    combinedExpression | letExpression
;
equalNotEqual:                                  (TEST_EQUAL | TEST_NOT_EQUAL) combinedArithmeticOnly
;
combinedArithmeticOnly:                         expression arithmeticPart*
;
expressionPart:                                 booleanPart | arithmeticPart
;
letExpression:                                  LET identifier EQUAL combinedExpression
;
combinedExpression:                             expression expressionPart*
;
expressionsArray:                               BRACKET_OPEN ( expression (COMMA expression)* )? BRACKET_CLOSE
;
propertyOrFunctionExpression:                   propertyExpression | functionExpression | propertyBracketExpression
;
propertyExpression:                             DOT identifier (functionExpressionLatestMilestoningDateParameter | functionExpressionParameters)?
;
propertyBracketExpression:                      BRACKET_OPEN (STRING | INTEGER)  BRACKET_CLOSE
;
functionExpression:                             ARROW qualifiedName functionExpressionParameters (ARROW qualifiedName functionExpressionParameters)*
;
functionExpressionLatestMilestoningDateParameter:
                                                PAREN_OPEN LATEST_DATE (COMMA LATEST_DATE)? PAREN_CLOSE
;
functionExpressionParameters:                   PAREN_OPEN (combinedExpression (COMMA combinedExpression)*)? PAREN_CLOSE
;
atomicExpression:                               dsl
                                                | instanceLiteralToken
                                                | expressionInstance
                                                | unitInstance
                                                | variable
                                                | columnBuilders
                                                | (AT type)
                                                | anyLambda
                                                | instanceReference
;

columnBuilders: TILDE (oneColSpec | colSpecArray)
;
oneColSpec: identifier ((COLON (type | anyLambda) extraFunction? ))?
;
colSpecArray: (BRACKET_OPEN (oneColSpec(COMMA oneColSpec)*)? BRACKET_CLOSE)
;
extraFunction: (COLON anyLambda)
;

anyLambda : lambdaPipe | lambdaFunction | lambdaParam lambdaPipe
;

instanceReference:                              (PATH_SEPARATOR | qualifiedName | unitName) allOrFunction?
;
lambdaFunction:                                 BRACE_OPEN (lambdaParam (COMMA lambdaParam)* )? lambdaPipe BRACE_CLOSE
;
variable:                                       DOLLAR identifier
;
allOrFunction:                                  allFunction
                                                | allVersionsFunction
                                                | allVersionsInRangeFunction
                                                | allFunctionWithMilestoning
                                                | functionExpressionParameters
;
allFunction:                                    DOT ALL PAREN_OPEN PAREN_CLOSE
;
allVersionsFunction:                            DOT ALL_VERSIONS PAREN_OPEN PAREN_CLOSE
;
allVersionsInRangeFunction:                     DOT ALL_VERSIONS_IN_RANGE PAREN_OPEN buildMilestoningVariableExpression COMMA buildMilestoningVariableExpression PAREN_CLOSE
;
allFunctionWithMilestoning:                     DOT ALL PAREN_OPEN buildMilestoningVariableExpression (COMMA buildMilestoningVariableExpression)? PAREN_CLOSE
;
buildMilestoningVariableExpression:             LATEST_DATE | DATE | variable
;
expressionInstance:                             NEW_SYMBOL (variable | qualifiedName)
                                                (LESS_THAN typeArguments? (PIPE multiplicityArguments)? GREATER_THAN)? (identifier)?
                                                (typeVariableValues)?
                                                PAREN_OPEN
                                                    expressionInstanceParserPropertyAssignment? (COMMA expressionInstanceParserPropertyAssignment)*
                                                PAREN_CLOSE
;
expressionInstanceRightSide:                    expressionInstanceAtomicRightSide
;
expressionInstanceAtomicRightSide:              combinedExpression | expressionInstance | qualifiedName
;
expressionInstanceParserPropertyAssignment:     identifier (DOT identifier)* PLUS? EQUAL expressionInstanceRightSide
;
notExpression:                                  NOT expression
;
signedExpression:                               (MINUS | PLUS) expression
;
lambdaPipe:                                     PIPE codeBlock
;
lambdaParam:                                    identifier lambdaParamType?
;
lambdaParamType:                                COLON type multiplicity
;
primitiveValue:                                 primitiveValueAtomic | primitiveValueVector
;
primitiveValueVector:                           BRACKET_OPEN (primitiveValueAtomic (COMMA primitiveValueAtomic)* )? BRACKET_CLOSE
;
primitiveValueAtomic:                           instanceLiteral | toBytesLiteral | enumReference
;
instanceLiteral:                                instanceLiteralToken | (MINUS INTEGER) | (MINUS FLOAT) | (MINUS DECIMAL) | (PLUS INTEGER) | (PLUS FLOAT) | (PLUS DECIMAL)
;
instanceLiteralToken:                           STRING | INTEGER | FLOAT | DECIMAL | DATE | BOOLEAN | STRICTTIME
;
toBytesLiteral:                                 TO_BYTES_FUNCTION PAREN_OPEN STRING PAREN_CLOSE
;
unitInstanceLiteral:                            (MINUS? INTEGER) | (MINUS? FLOAT) | (MINUS? DECIMAL) | (PLUS INTEGER) | (PLUS FLOAT) | (PLUS DECIMAL)
;
arithmeticPart:                                 (
                                                    PLUS expression (PLUS expression)*
                                                    | (STAR expression (STAR expression)*)
                                                    | (MINUS expression (MINUS expression)*)
                                                    | (DIVIDE expression (DIVIDE expression)*)
                                                    | (LESS_THAN expression)
                                                    | (LESS_OR_EQUAL expression)
                                                    | (GREATER_THAN expression)
                                                    | (GREATER_OR_EQUAL expression)
                                                )
;
booleanPart:                                    (AND expression) | (OR  expression)
;
functionVariableExpression:                     identifier COLON type multiplicity
;
dsl:                                            dslExtension | dslNavigationPath
;
dslNavigationPath:                              NAVIGATION_PATH_BLOCK
;
dslExtension:                                   ISLAND_OPEN (dslExtensionContent)*
;
dslExtensionContent:                            ISLAND_START | ISLAND_BRACE_OPEN | ISLAND_CONTENT | ISLAND_HASH | ISLAND_BRACE_CLOSE | ISLAND_END
;
type:                                           (qualifiedName (LESS_THAN typeArguments? (PIPE multiplicityArguments)? GREATER_THAN)?) typeVariableValues?
                                                |
                                                (
                                                    BRACE_OPEN
                                                        functionTypePureType? (COMMA functionTypePureType)*
                                                        ARROW type multiplicity
                                                    BRACE_CLOSE
                                                )
                                                |
                                                    relationType
                                                |
                                                unitName
;


relationType :  PAREN_OPEN
                   columnInfo (COMMA columnInfo)*
                PAREN_CLOSE
;

columnInfo: columnName COLON type multiplicity?
;

columnName: identifier
;

typeVariableValues: PAREN_OPEN (instanceLiteral (COMMA instanceLiteral)*)? PAREN_CLOSE
;

functionTypePureType:                           type multiplicity
;
typeAndMultiplicityParameters:                  LESS_THAN ((typeParameters multiplictyParameters?) | multiplictyParameters) GREATER_THAN
;
typeParametersWithContravarianceAndMultiplicityParameters:
                                                LESS_THAN ((contravarianceTypeParameters multiplictyParameters?) | multiplictyParameters) GREATER_THAN
;
typeParameters:                                 typeParameter (COMMA typeParameter)*
;
typeParameter:                                  identifier
;
contravarianceTypeParameters:                   contravarianceTypeParameter (COMMA contravarianceTypeParameter)*
;
contravarianceTypeParameter:                    MINUS? identifier
;
multiplicityArguments:                          multiplicityArgument (COMMA multiplicityArgument)*
;
typeArguments:                                  type (COMMA type)*
;
multiplictyParameters:                          PIPE identifier (COMMA identifier)*
;




multiplicity:                                   BRACKET_OPEN multiplicityArgument BRACKET_CLOSE
;
multiplicityArgument:                           identifier | ((fromMultiplicity DOT_DOT)? toMultiplicity)
;
fromMultiplicity:                               INTEGER
;
toMultiplicity:                                 INTEGER | STAR
;



functionIdentifier:                             qualifiedName PAREN_OPEN (functionTypePureType (COMMA functionTypePureType)*)? PAREN_CLOSE COLON functionTypePureType
;
