parser grammar LakehouseMappingParserGrammar;
import RelationalParserGrammar;

options
{
    tokenVocab = LakehouseMappingLexerGrammar;
}

// -------------------------------------- IDENTIFIER --------------------------------------
unquotedIdentifier: VALID_STRING
                  | ALL | LET | ALL_VERSIONS | ALL_VERSIONS_IN_RANGE
                  | TO_BYTES_FUNCTION
                  | INGEST_SOURCE_CMD | ACCESS_POINT_SOURCE_CMD
                  | JOIN
;

identifier: unquotedIdentifier | STRING
;

// -------------------------------------- LAKEHOUSE MAPPING DEFINITION --------------------------------------
lakehouseClassMapping: (ingestSrc | accessPointSrc)
                       (propertyMapping (COMMA propertyMapping)*)?
                       EOF
;

ingestSrc: INGEST_SOURCE_CMD databasePointer qualifiedName
;

accessPointSrc: ACCESS_POINT_SOURCE_CMD databasePointer qualifiedName
;

propertyMapping: qualifiedName STAR? COLON operation (PIPE tableAliasColumnOperation)?
;

mappingScopeInfo: unquotedIdentifier
;

// -------------------------------------- OPERATION --------------------------------------
operation: booleanOperation
         | functionExpression
;

functionExpression: databasePointer identifier ARROW identifier functionExpressionParameters
;

functionExpressionParameters: PAREN_OPEN (functionOperationArgument (COMMA functionOperationArgument)*)? PAREN_CLOSE
;

functionOperationArgument: operation | anyLambda | qualifiedName
;

anyLambda: BRACE_OPEN (lambdaParam (COMMA lambdaParam)*)? PIPE operation BRACE_CLOSE
;

lambdaParam: identifier
;

columnOperation: (databasePointer | variable)? tableAliasColumnOperation
;

variable: DOLLAR identifier
;

// -------------------------------------- BUILDING BLOCK --------------------------------------
scopeInfo: relationalIdentifier (DOT relationalIdentifier)?
;

databasePointer: BRACKET_OPEN qualifiedName BRACKET_CLOSE
;

relationalIdentifier: unquotedIdentifier | QUOTED_STRING
;




