
    @Test
    public void testLakehouseMappingJoin()
    {
        test("###Lakehouse\n" +
                "Ingest test::ingest::FirmIngest AppendOnly Undefined<CSV> owner=AppDir(prodParallel='1') group=test\n" +
                "[\n" +
                "   Firm(\n" +
                "      id: Varchar(200)[1],\n" +
                "      legalName: Varchar(200)[1]\n" +
                "   )\n" +
                "   DP10;\n" +
                "]\n" +
                "\n" +
                "\n" +
                "Ingest test::ingest::PersonIngest BatchMilestoned Snapshot<CSV> owner=AppDir(prodParallel='1') group=test\n" +
                "[\n" +
                "   Person(\n" +
                "      last_name: Varchar(200)[1],\n" +
                "      firm_id: Varchar(200)[1]\n" +
                "   )\n" +
                "   DP10\n" +
                "   pk=[firm_id];\n" +
                "]\n" +
                "\n" +
//                "###Pure\n" +
//                "function test::myFunc():meta::pure::metamodel::relation::Relation<Any>[1]\n" +
//                "{\n" +
//                "  test::model::Person.all()->project(~[firmID:x|$x.firm_id, Name:x|$x.lastName])->from(test::mapping::MyMap1, my::DuckDBRuntime)\n" +
//                "}\n" +
                "\n" +
                "\n" +
                "###Pure\n" +
                "Class test::model::Firm\n" +
                "{\n" +
                "  id: String[1];\n" +
                "  legalName: String[1];\n" +
                "}\n" +
                "\n" +
                "Class test::model::Person\n" +
                "{\n" +
                "  lastName: String[1];\n" +
                "  firm_id: Firm[1];\n" +
                "}\n" +
                "\n" +
                "\n" +
                "###Mapping\n" +
                "Mapping test::mapping::MyMap1\n" +
                "(\n" +
                "  test::model::Person: Lakehouse\n" +
                "  {\n" +
                "    ~ingestSource [test::ingest::PersonIngest]Person\n" +
                "    lastName: toUpper([test::ingest::PersonIngest]Person.last_name),\n" +
                "    firm_id: [test::ingest::PersonIngest]Person->join([test::ingest::FirmIngest]Firm, meta::pure::functions::relation::JoinKind.INNER, {x, y|$x.firm_id ==  $y.firm_id}) | [test::ingest::FirmIngest]Firm.id\n" +
                "  }\n" +
                ")\n"
        );
    }




package com.gs.alloy.lakehouse.runtime.model.grammar.parser;

import com.gs.alloy.lakehouse.ingest.api.accessor.protocol.IngestRelationAccessor;
import com.gs.alloy.lakehouse.protocol.pure.v1.model.packageableElement.mapping.ElementWithLakeJoins;
import com.gs.alloy.lakehouse.protocol.pure.v1.model.packageableElement.mapping.IngestRelationColumn;
import com.gs.alloy.lakehouse.protocol.pure.v1.model.packageableElement.mapping.LakehouseClassMapping;
import com.gs.alloy.lakehouse.protocol.pure.v1.model.packageableElement.mapping.LakehousePropertyMapping;
import com.gs.alloy.lakehouse.runtime.grammar.antlr4.LakehouseMappingParserGrammar;
import org.antlr.v4.runtime.CharStream;
import org.eclipse.collections.api.factory.Lists;
import org.eclipse.collections.impl.utility.ListIterate;
import org.finos.legend.engine.language.pure.grammar.from.ParseTreeWalkerSourceInformation;
import org.finos.legend.engine.language.pure.grammar.from.PureGrammarParserContext;
import org.finos.legend.engine.language.pure.grammar.from.PureGrammarParserUtility;
import org.finos.legend.engine.language.pure.grammar.from.antlr4.mapping.MappingParserGrammar;
import org.finos.legend.engine.protocol.pure.v1.model.context.EngineErrorType;
import org.finos.legend.engine.protocol.pure.v1.model.packageableElement.mapping.PropertyPointer;
import org.finos.legend.engine.protocol.pure.v1.model.packageableElement.store.relational.model.operation.DynaFunc;
import org.finos.legend.engine.protocol.pure.v1.model.packageableElement.store.relational.model.operation.Literal;
import org.finos.legend.engine.protocol.pure.v1.model.packageableElement.store.relational.model.operation.RelationalOperationElement;
import org.finos.legend.engine.shared.core.operational.errorManagement.EngineException;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class LakehouseClassMappingParseTreeWalker
{
    private final CharStream input;
    private final ParseTreeWalkerSourceInformation walkerSourceInformation;
    private final PureGrammarParserContext parserContext;

    public LakehouseClassMappingParseTreeWalker(ParseTreeWalkerSourceInformation walkerSourceInformation, CharStream input, PureGrammarParserContext parserContext)
    {
        this.input = input;
        this.walkerSourceInformation = walkerSourceInformation;
        this.parserContext = parserContext;
    }

    private String visitDatabasePointer(LakehouseMappingParserGrammar.DatabasePointerContext ctx)
    {
        return ctx != null ? PureGrammarParserUtility.fromQualifiedName(ctx.qualifiedName().packagePath() == null ? Collections.emptyList() : ctx.qualifiedName().packagePath().identifier(), ctx.qualifiedName().identifier()) : null;
    }

    private String visitMappingScopeInfo(LakehouseMappingParserGrammar.MappingScopeInfoContext ctx)
    {
        return ctx != null ? PureGrammarParserUtility.fromIdentifier(ctx.unquotedIdentifier()) : null;
    }

    public void visitLakehouseClassMapping(LakehouseMappingParserGrammar.LakehouseClassMappingContext ctx, MappingParserGrammar.MappingElementContext classMappingContext, LakehouseClassMapping lakehouseClassMapping)
    {
        if (ctx.ingestSrc() != null)
        {
            IngestRelationAccessor tmp = new IngestRelationAccessor();
            tmp.path = Lists.mutable.with(visitDatabasePointer(ctx.ingestSrc().databasePointer()), ctx.ingestSrc().qualifiedName().getText());
            tmp.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx.ingestSrc());
            lakehouseClassMapping.ingestPtr = tmp;
        }
        else if (ctx.accessPointSrc() != null)
        {
            IngestRelationAccessor tmp = new IngestRelationAccessor();
            tmp.path = Lists.mutable.with(visitDatabasePointer(ctx.accessPointSrc().databasePointer()), ctx.accessPointSrc().qualifiedName().getText());
            tmp.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx.accessPointSrc());
            lakehouseClassMapping.ingestPtr = tmp;
        }
        lakehouseClassMapping.propertyMappings = ListIterate.collect(ctx.propertyMapping(), propertyMappingContext -> visitPropertyMapping(propertyMappingContext, classMappingContext, lakehouseClassMapping));
    }

    private LakehousePropertyMapping visitPropertyMapping(LakehouseMappingParserGrammar.PropertyMappingContext ctx, MappingParserGrammar.MappingElementContext classMappingContext, LakehouseClassMapping lakehouseClassMapping)
    {
        LakehousePropertyMapping propertyMapping = new LakehousePropertyMapping();
        propertyMapping.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
        PropertyPointer propertyPointer = new PropertyPointer();
        propertyPointer.property = PureGrammarParserUtility.fromIdentifier(ctx.qualifiedName());
        propertyPointer._class = lakehouseClassMapping._class;
        propertyPointer.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
        propertyMapping.property = propertyPointer;
        propertyMapping.source = lakehouseClassMapping.id;

        RelationalOperationElement operation = visitOperation(ctx.operation(0), lakehouseClassMapping.ingestPtr);

        // Handle projection if present
        if (ctx.operation().size() > 1) // Second operation is the projection
        {
            ElementWithLakeJoins elementWithJoins = new ElementWithLakeJoins();
            elementWithJoins.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);

            // Extract join information if the operation is a join
            if (operation instanceof DynaFunc && "join".equals(((DynaFunc) operation).funcName))
            {
                DynaFunc joinFunc = (DynaFunc) operation;
                if (joinFunc.parameters.size() == 4) // >= 3
                {
                    if (joinFunc.parameters.get(0) instanceof IngestRelationColumn &&
                        joinFunc.parameters.get(1) instanceof IngestRelationColumn &&
                        joinFunc.parameters.get(2) instanceof Literal &&
                        joinFunc.parameters.get(3) instanceof DynaFunc)
                    {
                        elementWithJoins.source1 = ((IngestRelationColumn) joinFunc.parameters.get(0)).ingestAccessor;
                        elementWithJoins.source2 = ((IngestRelationColumn) joinFunc.parameters.get(1)).ingestAccessor; // Note: source2 will be set correctly in visitFunctionExpression
                        elementWithJoins.joinType = ((Literal) joinFunc.parameters.get(2)).value.toString();
                        elementWithJoins.condition = (DynaFunc) joinFunc.parameters.get(3);
                        // Set lambda parameter names
                        LakehouseMappingParserGrammar.FunctionExpressionParametersContext paramsCtx = ctx.operation(0).functionExpression().functionExpressionParameters();
                        if (paramsCtx != null && paramsCtx.functionOperationArgument().size() >= 3 && paramsCtx.functionOperationArgument(2).anyLambda() != null)
                        {
                            elementWithJoins.conditionParametersNames = ListIterate.collect(
                                    paramsCtx.functionOperationArgument(2).anyLambda().lambdaParam(),
                                    param -> PureGrammarParserUtility.fromIdentifier(param.identifier())
                            );
                        }
                    }
                    else
                    {
                        throw new EngineException("Invalid join operation parameters", this.walkerSourceInformation.getSourceInformation(ctx), EngineErrorType.PARSER);
                    }
                }
            }

            // Set the projection as the relationalElement
            elementWithJoins.relationalElement = visitOperation(ctx.operation(1), lakehouseClassMapping.ingestPtr);
            propertyMapping.relationalOperation = elementWithJoins;
        }
        else
        {
            propertyMapping.relationalOperation = operation;
        }

        return propertyMapping;
    }

    private RelationalOperationElement visitOperation(LakehouseMappingParserGrammar.OperationContext ctx, IngestRelationAccessor ingestPtr)
    {
        if (ctx.booleanOperation() != null)
        {
            return visitBooleanOperation(ctx.booleanOperation(), ingestPtr);
        }
        else if (ctx.functionExpression() != null)
        {
            return visitFunctionExpression(ctx.functionExpression(), ingestPtr);
        }
        else if (ctx.expression() != null)
        {
            return visitExpression(ctx.expression(), ingestPtr);
        }
        throw new EngineException("Unsupported operation syntax", this.walkerSourceInformation.getSourceInformation(ctx), EngineErrorType.PARSER);
    }

    private RelationalOperationElement visitBooleanOperation(LakehouseMappingParserGrammar.BooleanOperationContext ctx, IngestRelationAccessor ingestPtr)
    {
        RelationalOperationElement operationElement = visitAtomicExpression(ctx.atomicExpression(), ingestPtr);
        if (ctx.booleanOperationRight() != null)
        {
            DynaFunc operation = new DynaFunc();
            operation.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
            operation.funcName = ctx.booleanOperationRight().booleanOperator().AND() != null ? "and" : "or";
            operation.parameters = new ArrayList<>();
            operation.parameters.add(operationElement);
            RelationalOperationElement right = visitOperation(ctx.booleanOperationRight().operation(), ingestPtr);
            operation.parameters.add(right);
            return operation;
        }
        return operationElement;
    }

    private RelationalOperationElement visitFunctionExpression(LakehouseMappingParserGrammar.FunctionExpressionContext ctx, IngestRelationAccessor ingestPtr)
    {
        DynaFunc operation = new DynaFunc();
        operation.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);

        operation.parameters = new ArrayList<>();
        // Determine if this is a simple function call or database pointer function call
        if (ctx.databasePointer() != null)
        {
            operation.funcName = PureGrammarParserUtility.fromIdentifier(ctx.identifier(1)); // Function name (e.g., "join", "toUpper")
            IngestRelationColumn sourceColumn = new IngestRelationColumn();
            sourceColumn.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx.databasePointer());
            sourceColumn.ingestAccessor = new IngestRelationAccessor();
            sourceColumn.ingestAccessor.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx.databasePointer());
            String sourceDb = visitDatabasePointer(ctx.databasePointer());
            String sourceTable = PureGrammarParserUtility.fromIdentifier(ctx.identifier(0));
            sourceColumn.ingestAccessor.path = Lists.mutable.with(sourceDb, sourceTable);
            // sourceColumn.column = null; // Table-level reference


            LakehouseMappingParserGrammar.FunctionExpressionParametersContext paramsCtx = ctx.functionExpressionParameters();
            List<IngestRelationAccessor> lambdaAccessors = new ArrayList<>();
            if (operation.funcName.equals("join") && paramsCtx.functionOperationArgument().size() >= 3)
            {
                // For join, store source and target accessors for lambda parameters
                // IngestRelationColumn targetColumn = (IngestRelationColumn) visitFunctionOperationArgument(paramsCtx.functionOperationArgument(0), ingestPtr);
                RelationalOperationElement targetArg = visitFunctionOperationArgument(paramsCtx.functionOperationArgument(0), ingestPtr);
                if (!(targetArg instanceof IngestRelationColumn))
                {
                    throw new EngineException("Join target must be a table reference", this.walkerSourceInformation.getSourceInformation(paramsCtx.functionOperationArgument(0)), EngineErrorType.PARSER);
                }
                IngestRelationColumn targetColumn = (IngestRelationColumn) targetArg;
                lambdaAccessors.add(sourceColumn.ingestAccessor); // x
                lambdaAccessors.add(targetColumn.ingestAccessor); // y

                // Update ElementWithLakeJoins if this is part of a join
                if (ctx.getParent() instanceof LakehouseMappingParserGrammar.PropertyMappingContext)
                {
                    LakehouseMappingParserGrammar.PropertyMappingContext parentCtx = (LakehouseMappingParserGrammar.PropertyMappingContext) ctx.getParent();
                    ElementWithLakeJoins elementWithJoins = new ElementWithLakeJoins();
                    elementWithJoins.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
                    elementWithJoins.source1 = sourceColumn.ingestAccessor;
                    elementWithJoins.source2 = targetColumn.ingestAccessor;
                    RelationalOperationElement joinTypeArg = visitFunctionOperationArgument(paramsCtx.functionOperationArgument(1), ingestPtr);
                    if (!(joinTypeArg instanceof Literal))
                    {
                        throw new EngineException("Join type must be a literal (e.g., meta::pure::functions::relation::JoinKind.INNER)", this.walkerSourceInformation.getSourceInformation(paramsCtx.functionOperationArgument(1)), EngineErrorType.PARSER);
                    }
                    elementWithJoins.joinType = ((Literal) joinTypeArg).value.toString();
                    RelationalOperationElement conditionArg = visitFunctionOperationArgument(paramsCtx.functionOperationArgument(2), lambdaAccessors);
                    if (!(conditionArg instanceof DynaFunc))
                    {
                        throw new EngineException("Join condition must be a lambda", this.walkerSourceInformation.getSourceInformation(paramsCtx.functionOperationArgument(2)), EngineErrorType.PARSER);
                    }
                    elementWithJoins.condition = (DynaFunc) conditionArg;
                    // Set lambda parameter names
                    if (paramsCtx.functionOperationArgument(2).anyLambda() != null)
                    {
                        elementWithJoins.conditionParametersNames = ListIterate.collect(
                                paramsCtx.functionOperationArgument(2).anyLambda().lambdaParam(),
                                param -> PureGrammarParserUtility.fromIdentifier(param.identifier())
                        );
                    }
                    if (parentCtx.operation().size() > 1)
                    {
                        elementWithJoins.relationalElement = visitOperation(parentCtx.operation(1), ingestPtr);
//                        elementWithJoins.relationalElement = visitOperation(parentCtx.operation(1), lambdaAccessors);
                    }
                    return elementWithJoins;
                }

                operation.parameters.add(sourceColumn);
                operation.parameters.add(targetColumn);
                operation.parameters.add(visitFunctionOperationArgument(paramsCtx.functionOperationArgument(1), ingestPtr)); // JoinKind.INNER
                operation.parameters.add(visitFunctionOperationArgument(paramsCtx.functionOperationArgument(2), lambdaAccessors)); // Lambda
            }
        }
        else
        {
            // Simple function call: toUpper(...)
            operation.funcName = PureGrammarParserUtility.fromIdentifier(ctx.identifier(0)); // Function name
            // For non-join functions (e.g., toUpper), use default ingestPtr
            LakehouseMappingParserGrammar.FunctionExpressionParametersContext paramsCtx = ctx.functionExpressionParameters();
            operation.parameters = ListIterate.collect(paramsCtx.functionOperationArgument(), argCtx -> visitFunctionOperationArgument(argCtx, ingestPtr));
        }

        // Parse function parameters
//        if (ctx.functionExpressionParameters() != null)
//        {
//        }

        return operation;
    }

    private RelationalOperationElement visitExpression(LakehouseMappingParserGrammar.ExpressionContext ctx, IngestRelationAccessor ingestPtr)
    {
        RelationalOperationElement left = visitAtomicExpression(ctx.atomicExpression(), ingestPtr);
        if (ctx.equalNotEqual() != null)
        {
            DynaFunc operation = new DynaFunc();
            operation.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
            operation.funcName = ctx.equalNotEqual().TEST_EQUAL() != null ? "equal" : "notEqual";
            operation.parameters = new ArrayList<>();
            operation.parameters.add(left);
            operation.parameters.add(visitAtomicExpression(ctx.equalNotEqual().atomicExpression(), ingestPtr));
            return operation;
        }
        return left;
    }

//    private String visitAtomicOperator(LakehouseMappingParserGrammar.AtomicOperatorContext ctx)
//    {
//        if (ctx.EQUAL() != null)
//        {
//            return "equal";
//        }
//        if (ctx.TEST_NOT_EQUAL() != null || ctx.NOT_EQUAL() != null)
//        {
//            return "notEqual";
//        }
//        if (ctx.GREATER_THAN() != null)
//        {
//            return "greaterThan";
//        }
//        if (ctx.LESS_THAN() != null)
//        {
//            return "lessThan";
//        }
//        if (ctx.GREATER_OR_EQUAL() != null)
//        {
//            return "greaterThanEqual";
//        }
//        if (ctx.LESS_OR_EQUAL() != null)
//        {
//            return "lessThanEqual";
//        }
//        throw new EngineException("Unsupported operator", this.walkerSourceInformation.getSourceInformation(ctx), EngineErrorType.PARSER);
//    }
//
//    private String visitAtomicSelfOperator(LakehouseMappingParserGrammar.AtomicSelfOperatorContext ctx)
//    {
//        if (ctx.IS_NULL() != null)
//        {
//            return "isNull";
//        }
//        if (ctx.IS_NOT_NULL() != null)
//        {
//            return "isNotNull";
//        }
//        throw new EngineException("Unsupported self operator", this.walkerSourceInformation.getSourceInformation(ctx), EngineErrorType.PARSER);
//    }

    private RelationalOperationElement visitAtomicExpression(LakehouseMappingParserGrammar.AtomicExpressionContext ctx, IngestRelationAccessor ingestPtr)
    {
        if (ctx.columnOperation() != null)
        {
            return visitColumnOperation(ctx.columnOperation(), ingestPtr);
        }
        else if (ctx.constant() != null)
        {
            Literal constant = new Literal();
            constant.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
            if (ctx.constant().STRING() != null)
            {
                constant.value = PureGrammarParserUtility.fromGrammarString(ctx.constant().STRING().getText(), true);
            }
            else if (ctx.constant().INTEGER() != null)
            {
                constant.value = Integer.parseInt(ctx.constant().INTEGER().getText());
            }
            else if (ctx.constant().FLOAT() != null)
            {
                constant.value = Double.parseDouble(ctx.constant().FLOAT().getText());
            }
            else
            {
                throw new EngineException("Unsupported constant syntax", this.walkerSourceInformation.getSourceInformation(ctx), EngineErrorType.PARSER);
            }
            return constant;
        }
        else if (ctx.anyLambda() != null)
        {
            return visitAnyLambda(ctx.anyLambda(), ingestPtr);
        }
        else if (ctx.operation() != null)
        {
            return visitOperation(ctx.operation(), ingestPtr);
        }
        throw new EngineException("Unsupported atomic expression syntax", this.walkerSourceInformation.getSourceInformation(ctx), EngineErrorType.PARSER);
    }

    private RelationalOperationElement visitAnyLambda(LakehouseMappingParserGrammar.AnyLambdaContext ctx, Object ingestPtr)
    {
        DynaFunc lambda = new DynaFunc();
        lambda.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
        lambda.funcName = "lambda";
        lambda.parameters = new ArrayList<>();
        // lambda.parametersNames = ListIterate.collect(ctx.lambdaParam(), param -> PureGrammarParserUtility.fromIdentifier(param.identifier()));
        if (ctx.operation() != null)
        {
//            lambda.parameters.add(visitOperation(ctx.operation(), ingestPtr));
            IngestRelationAccessor accessor = ingestPtr instanceof IngestRelationAccessor ? (IngestRelationAccessor) ingestPtr : (ingestPtr instanceof List ? ((List<IngestRelationAccessor>) ingestPtr).get(0) : null);
            lambda.parameters.add(visitOperation(ctx.operation(), accessor));
        }
        return lambda;
    }

    private RelationalOperationElement visitFunctionOperationArgument(LakehouseMappingParserGrammar.FunctionOperationArgumentContext ctx, Object ingestPtr)
    {
        if (ctx.qualifiedName() != null && ctx.identifier() != null)
        {
            Literal literal = new Literal();
            literal.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
            literal.value = PureGrammarParserUtility.fromQualifiedName(ctx.qualifiedName().packagePath() == null ? Collections.emptyList() : ctx.qualifiedName().packagePath().identifier(), ctx.qualifiedName().identifier()) + '.' + PureGrammarParserUtility.fromIdentifier(ctx.identifier());
            return literal;
        }
        else if (ctx.databasePointer() != null && ctx.identifier() != null)
        {
            IngestRelationColumn tableRef = new IngestRelationColumn();
            tableRef.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
            tableRef.ingestAccessor = new IngestRelationAccessor();
            tableRef.ingestAccessor.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
            String databasePath = visitDatabasePointer(ctx.databasePointer());
            String tableName = PureGrammarParserUtility.fromIdentifier(ctx.identifier());
            tableRef.ingestAccessor.path = Lists.mutable.with(databasePath, tableName);
            tableRef.column = null; // Table-level reference, no column
            return tableRef;
        }
        else if (ctx.anyLambda() != null)
        {
//            return visitAnyLambda(ctx.anyLambda(), ingestPtr instanceof List ? ((List<IngestRelationAccessor>) ingestPtr).get(1) : (IngestRelationAccessor) ingestPtr);
            return visitAnyLambda(ctx.anyLambda(), ingestPtr);
        }
        else if (ctx.operation() != null)
        {
            IngestRelationAccessor accessor = ingestPtr instanceof IngestRelationAccessor ? (IngestRelationAccessor) ingestPtr : (ingestPtr instanceof List ? ((List<IngestRelationAccessor>) ingestPtr).get(0) : null);
            return visitOperation(ctx.operation(), accessor);
        }
        throw new EngineException("Unsupported function argument syntax", this.walkerSourceInformation.getSourceInformation(ctx), EngineErrorType.PARSER);
    }

    private RelationalOperationElement visitColumnOperation(LakehouseMappingParserGrammar.ColumnOperationContext ctx, IngestRelationAccessor ingestPtr)
    {
        if (ctx.tableAliasColumnOperation() != null)
        {
            return visitTableAliasColumnOperation(ctx.tableAliasColumnOperation(), ingestPtr);
        }
        else if (ctx.variable() != null && ctx.relationalIdentifier() != null)
        {
            IngestRelationColumn column = new IngestRelationColumn();
            column.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
            column.ingestAccessor = new IngestRelationAccessor();
            column.ingestAccessor.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
            String paramName = PureGrammarParserUtility.fromIdentifier(ctx.variable().identifier());
            if (!paramName.equals("x") && !paramName.equals("y"))
            {
                throw new EngineException("Unsupported lambda parameter: $" + paramName, this.walkerSourceInformation.getSourceInformation(ctx), EngineErrorType.PARSER);
            }
            if (ingestPtr == null)
            {
                throw new EngineException("No IngestRelationAccessor provided for lambda parameter: $" + paramName, this.walkerSourceInformation.getSourceInformation(ctx), EngineErrorType.PARSER);
            }
            // Use the correct IngestRelationAccessor based on lambda parameter
            IngestRelationAccessor accessor = (ingestPtr instanceof List && ((List<IngestRelationAccessor>) ingestPtr).size() >= 2)
                    ? (paramName.equals("x") ? ((List<IngestRelationAccessor>) ingestPtr).get(0) : ((List<IngestRelationAccessor>) ingestPtr).get(1))
                    : ingestPtr;
            column.ingestAccessor.path = Lists.mutable.with(accessor.path.get(0), accessor.path.get(1));
            column.column = ctx.relationalIdentifier().QUOTED_STRING() != null
                    ? PureGrammarParserUtility.fromGrammarString(ctx.relationalIdentifier().QUOTED_STRING().getText(), true)
                    : PureGrammarParserUtility.fromIdentifier(ctx.relationalIdentifier().unquotedIdentifier());
            return column;
        }
        throw new EngineException("Unsupported column operation syntax", this.walkerSourceInformation.getSourceInformation(ctx), EngineErrorType.PARSER);
    }

    private RelationalOperationElement visitTableAliasColumnOperation(LakehouseMappingParserGrammar.TableAliasColumnOperationContext ctx, IngestRelationAccessor ingestPtr)
    {
        return visitTableAliasColumnOperationWithScopeInfo(ctx.tableAliasColumnOperationWithScopeInfo(), ingestPtr);
    }

    private RelationalOperationElement visitTableAliasColumnOperationWithScopeInfo(LakehouseMappingParserGrammar.TableAliasColumnOperationWithScopeInfoContext ctx, IngestRelationAccessor ingestPtr)
    {
        IngestRelationColumn column = new IngestRelationColumn();
        column.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
        column.ingestAccessor = new IngestRelationAccessor();
        column.ingestAccessor.sourceInformation = this.walkerSourceInformation.getSourceInformation(ctx);
        String databasePath = ingestPtr != null ? ingestPtr.path.get(0) : null;
        String tableName = ctx.relationalIdentifier().QUOTED_STRING() != null
                ? PureGrammarParserUtility.fromGrammarString(ctx.relationalIdentifier().QUOTED_STRING().getText(), true)
                : PureGrammarParserUtility.fromIdentifier(ctx.relationalIdentifier().unquotedIdentifier());
        column.ingestAccessor.path = Lists.mutable.with(databasePath, tableName);
        if (ctx.scopeInfo() != null && ctx.scopeInfo().relationalIdentifier().size() > 0)
        {
            column.column = ctx.scopeInfo().relationalIdentifier(0).QUOTED_STRING() != null
                    ? PureGrammarParserUtility.fromGrammarString(ctx.scopeInfo().relationalIdentifier(0).QUOTED_STRING().getText(), true)
                    : PureGrammarParserUtility.fromIdentifier(ctx.scopeInfo().relationalIdentifier(0).unquotedIdentifier());
        }
        else
        {
            throw new EngineException("Column name is required in scopeInfo", this.walkerSourceInformation.getSourceInformation(ctx), EngineErrorType.PARSER);
        }
        return column;
    }
}






package com.gs.alloy.lakehouse.runtime.model.grammar.serializer;

import com.gs.alloy.lakehouse.ingest.api.accessor.protocol.IngestRelationAccessor;
import com.gs.alloy.lakehouse.protocol.pure.v1.model.packageableElement.mapping.ElementWithLakeJoins;
import com.gs.alloy.lakehouse.protocol.pure.v1.model.packageableElement.mapping.IngestRelationColumn;
import com.gs.alloy.lakehouse.protocol.pure.v1.model.packageableElement.mapping.LakehouseClassMapping;
import com.gs.alloy.lakehouse.protocol.pure.v1.model.packageableElement.mapping.LakehousePropertyMapping;
import com.gs.alloy.lakehouse.protocol.pure.v1.model.packageableElement.runtime.LakehouseRuntime;
import com.gs.alloy.lakehouse.runtime.model.grammar.parser.LakehouseRuntimeParserExtension;
import org.eclipse.collections.api.block.function.Function2;
import org.eclipse.collections.api.block.function.Function3;
import org.eclipse.collections.api.factory.Lists;
import org.eclipse.collections.api.list.MutableList;
import org.eclipse.collections.impl.utility.Iterate;
import org.eclipse.collections.impl.utility.LazyIterate;
import org.eclipse.collections.impl.utility.ListIterate;
import org.finos.legend.engine.language.pure.grammar.to.HelperDomainGrammarComposer;
import org.finos.legend.engine.language.pure.grammar.to.PureGrammarComposerContext;
import org.finos.legend.engine.language.pure.grammar.to.PureGrammarComposerUtility;
import org.finos.legend.engine.language.pure.grammar.to.extension.PureGrammarComposerExtension;
import org.finos.legend.engine.protocol.pure.m3.PackageableElement;
import org.finos.legend.engine.protocol.pure.v1.model.packageableElement.mapping.ClassMapping;
import org.finos.legend.engine.protocol.pure.v1.model.packageableElement.mapping.PropertyMapping;
import org.finos.legend.engine.protocol.pure.v1.model.packageableElement.runtime.PackageableRuntime;
import org.finos.legend.engine.protocol.pure.v1.model.packageableElement.store.relational.model.operation.DynaFunc;
import org.finos.legend.engine.protocol.pure.v1.model.packageableElement.store.relational.model.operation.Literal;
import org.finos.legend.engine.protocol.pure.v1.model.packageableElement.store.relational.model.operation.RelationalOperationElement;

import java.util.Collections;
import java.util.List;

import static org.finos.legend.engine.language.pure.grammar.to.PureGrammarComposerUtility.appendTabString;
import static org.finos.legend.engine.language.pure.grammar.to.PureGrammarComposerUtility.getTabString;

public class LakehouseRuntimeGrammarComposerExtension implements PureGrammarComposerExtension
{
    @Override
    public MutableList<String> group()
    {
        return org.eclipse.collections.impl.factory.Lists.mutable.with("PackageableElement", "LakehouseRuntime");
    }

    @Override
    public List<Function3<List<PackageableElement>, PureGrammarComposerContext, List<String>, PureFreeSectionGrammarComposerResult>> getExtraFreeSectionComposers()
    {
        return Collections.singletonList((elements, context, composedSections) ->
        {
            MutableList<PackageableElement> composableElements = Iterate.select(elements, e -> (e instanceof PackageableRuntime && ((PackageableRuntime) e).runtimeValue instanceof LakehouseRuntime), Lists.mutable.empty());
            return composableElements.isEmpty()
                    ? null
                    : new PureFreeSectionGrammarComposerResult(composableElements.asLazy().collect(element -> renderLakehouseRuntime(((PackageableRuntime) element), context)).makeString("###" + LakehouseRuntimeParserExtension.NAME + "\n", "\n\n", ""), composableElements);
        });
    }

    private static String renderLakehouseRuntime(PackageableRuntime lakeRuntime, PureGrammarComposerContext context)
    {
        String runtimeType = "LakehouseRuntime ";
        return runtimeType + PureGrammarComposerUtility.convertPath(lakeRuntime.getPath()) + "\n" +
                "{" +
                     renderRuntimeValue((LakehouseRuntime) lakeRuntime.runtimeValue, 1) +
                "\n}";
    }

    private static String renderRuntimeValue(LakehouseRuntime runtimeValue, int baseIndentation)
    {
        StringBuilder builder = new StringBuilder();
        if (runtimeValue.environment != null && runtimeValue.warehouse != null)
        {
            appendTabString(builder.append("\n"), baseIndentation).append("environment: '").append(runtimeValue.environment).append("';");
            appendTabString(builder.append("\n"), baseIndentation).append("warehouse: '").append(runtimeValue.warehouse).append("';");
        }
        else if (runtimeValue.environment == null && runtimeValue.warehouse == null && runtimeValue.connectionPointer != null)
        {
            appendTabString(builder.append("\n"), baseIndentation).append("connection: ").append(PureGrammarComposerUtility.convertPath(runtimeValue.connectionPointer.connection)).append(";");
        }
        return builder.toString();
    }

    @Override
    public List<Function3<List<PackageableElement>, PureGrammarComposerContext, String, String>> getExtraSectionComposers()
    {
        return Lists.fixedSize.with((elements, context, sectionName) ->
        {
            if (!LakehouseRuntimeParserExtension.NAME.equals(sectionName))
            {
                return null;
            }
            return ListIterate.collect(elements, element ->
            {
                if (element instanceof PackageableRuntime)
                {
                    return renderLakehouseRuntime((PackageableRuntime) element, context);
                }
                return "/* Can't transform element '" + element.getPath() + "' in this section */";
            }).makeString("\n\n");
        });
    }

    @Override
    public List<Function2<ClassMapping, PureGrammarComposerContext, String>> getExtraClassMappingComposers()
    {
        return org.eclipse.collections.impl.factory.Lists.mutable.with((classMapping, context) ->
        {
            if (classMapping instanceof LakehouseClassMapping)
            {
                LakehouseClassMapping lakehouseClassMapping = (LakehouseClassMapping) classMapping;
                StringBuilder builder = new StringBuilder();
                builder.append(": ").append(LakehouseRuntimeParserExtension.LAKEHOUSE_MAPPING_ELEMENT_TYPE).append("\n");
                builder.append(getTabString()).append("{\n");
                String mapping = renderLakehouseClassMapping(lakehouseClassMapping);
                builder.append(mapping);
                builder.append(getTabString()).append("}");
                return builder.toString();
            }
            return null;
        });
    }

    private String renderLakehouseClassMapping(LakehouseClassMapping lakehouseClassMapping)
    {
        StringBuilder builder = new StringBuilder();
        if (lakehouseClassMapping.ingestPtr != null)
        {
            IngestRelationAccessor tmp = lakehouseClassMapping.ingestPtr;
            appendTabString(builder, 2).append("~ingestSource ");
            builder.append("[").append(tmp.path.get(0)).append("]");
            builder.append(tmp.path.get(1));
            builder.append("\n");
        }
        if (!lakehouseClassMapping.propertyMappings.isEmpty())
        {
            builder.append(LazyIterate.collect(lakehouseClassMapping.propertyMappings, propertyMapping ->
                    renderRelationalPropertyMapping(propertyMapping, false)).makeString(",\n"));
            builder.append("\n");
        }
        return builder.toString();
    }

    private static boolean checkNullOrEmpty(String string)
    {
        return string == null || string.isEmpty();
    }

    private static String renderRelationalPropertyMapping(PropertyMapping relationalPropertyMapping, Boolean renderSourceId)
    {
        LakehousePropertyMapping lakehousePropertyMapping = (LakehousePropertyMapping) relationalPropertyMapping;
        String propertyString = getTabString(2) + (relationalPropertyMapping.localMappingProperty != null
                ? ("+" + PureGrammarComposerUtility.convertIdentifier(relationalPropertyMapping.property.property) + ": " +
                relationalPropertyMapping.localMappingProperty.type + "[" +
                HelperDomainGrammarComposer.renderMultiplicity(relationalPropertyMapping.localMappingProperty.multiplicity) + "]")
                : PureGrammarComposerUtility.convertIdentifier(relationalPropertyMapping.property.property) +
                (checkNullOrEmpty(relationalPropertyMapping.target) ? "" : "[" + (renderSourceId ?
                        (checkNullOrEmpty(relationalPropertyMapping.source) ? "" : (relationalPropertyMapping.source + ",")) : "") +
                        relationalPropertyMapping.target + "]")
        ) + ": ";
        return propertyString + renderRelationalOperationElement(lakehousePropertyMapping.relationalOperation);
    }

    private static String renderRelationalOperationElement(RelationalOperationElement operation)
    {
        if (operation instanceof DynaFunc)
        {
            DynaFunc func = (DynaFunc) operation;
            StringBuilder builder = new StringBuilder();
            builder.append(PureGrammarComposerUtility.convertIdentifier(func.funcName));
            builder.append("(");
            builder.append(ListIterate.collect(func.parameters, param -> renderRelationalOperationElement(param)).makeString(", "));
            builder.append(")");
            return builder.toString();
        }
        else if (operation instanceof IngestRelationColumn)
        {
            IngestRelationColumn column = (IngestRelationColumn) operation;
            StringBuilder builder = new StringBuilder();
            if (column.ingestAccessor != null && !column.ingestAccessor.path.isEmpty())
            {
                builder.append("[").append(column.ingestAccessor.path.get(0)).append("]").append(column.ingestAccessor.path.get(1));
            }
            if (column.column != null)
            {
                builder.append(".").append(column.column);
            }
            return builder.toString();
        }
        else if (operation instanceof Literal)
        {
            Literal literal = (Literal) operation;
            if (literal.value instanceof String)
            {
                return PureGrammarComposerUtility.convertString((String) literal.value, true);
            }
            return literal.value.toString();
        }
        else if (operation instanceof ElementWithLakeJoins)
        {
            ElementWithLakeJoins join = (ElementWithLakeJoins) operation;
            StringBuilder builder = new StringBuilder();
            // Serialize source1
            if (join.source1 != null && !join.source1.path.isEmpty())
            {
                builder.append("[").append(join.source1.path.get(0)).append("]").append(join.source1.path.get(1));
            }
            // Serialize join function
            builder.append("->join(");
            // Serialize source2
            if (join.source2 != null && !join.source2.path.isEmpty())
            {
                builder.append("[").append(join.source2.path.get(0)).append("]").append(join.source2.path.get(1));
            }
            // Serialize joinType
            if (join.joinType != null)
            {
//                builder.append(", ").append(PureGrammarComposerUtility.convertString(join.joinType, false));
                builder.append(", ").append(join.joinType);
            }
            // Serialize condition
            if (join.condition != null)
            {
                builder.append(", ").append(renderRelationalOperationElement(join.condition));
            }
            builder.append(")");
            // Serialize projection
            if (join.relationalElement != null)
            {
                builder.append(" | ").append(renderRelationalOperationElement(join.relationalElement));
            }
            return builder.toString();
        }
        throw new IllegalStateException("Unsupported operation type: " + operation.getClass().getSimpleName());
    }
}



expected - firm_id: [test::ingest::PersonIngest]Person->join([test::ingest::FirmIngest]Firm, meta::pure::functions::relation::JoinKind.INNER, {x, y|$x.firm_id ==  $y.firm_id}) | [test::ingest::FirmIngest]Firm.id
actual -   firm_id: [test::ingest::PersonIngest]Person->join([test::ingest::FirmIngest]Firm, meta::pure::functions::relation::JoinKind.INNER, lambda(equal([test::ingest::PersonIngest]Person.firm_id, [test::ingest::PersonIngest]Person.firm_id))) | [test::ingest::PersonIngest]Firm.id
  


