import meta::pure::metamodel::dataSpace::*;
import meta::pure::graphFetch::*;
import meta::pure::metamodel::constraint::*;
import meta::core::runtime::*;
import meta::external::dataquality::*;
import meta::pure::metamodel::relation::*;

Class meta::external::dataquality::DataQualityRootGraphFetchTree<T> extends RootGraphFetchTree<T>
[
  mustHaveAtLeastOnePropertyOrConstraint: $this.constraints->isNotEmpty() || $this.subTrees->isNotEmpty()
]
{
   constraints: Constraint[*]; 
   
}

Class meta::external::dataquality::DataQualityPropertyGraphFetchTree extends PropertyGraphFetchTree
{
  constraints: Constraint[*];
}

Class meta::external::dataquality::DataQuality<T> extends PackageableElement
{
  context: DataQualityExecutionContext[1];
  validationTree: DataQualityRootGraphFetchTree<T>[1];
  filter : LambdaFunction<{T[1]->Boolean[1]}>[0..1]; //typed params
}

Class meta::external::dataquality::DataQualityExecutionContext
{
}

Class meta::external::dataquality::MappingAndRuntimeDataQualityExecutionContext extends meta::external::dataquality::DataQualityExecutionContext
{
  mapping: meta::pure::mapping::Mapping[1];
  runtime: meta::core::runtime::Runtime[1];
}

Class meta::external::dataquality::DataSpaceDataQualityExecutionContext extends meta::external::dataquality::DataQualityExecutionContext
{
  dataSpace: DataSpace[1];
  contextName: String[1];
}

Class meta::external::dataquality::DataQualityRule
{
  constraintName: String[1];
  constraintType : String[1];
  constraintGrammar: String[1];
  propertyPath: String[1];
}

Class meta::external::dataquality::DataQualityRelationValidation extends PackageableElement
{
  query: LambdaFunction<Any>[1];                                         // should return a relation - enforced in compiler
  validations: RelationValidation[*];
}

Class meta::external::dataquality::RelationValidation
{
  name: String[1];
  description: String[0..1];
  assertion: LambdaFunction<Any>[1];
  type: String[0..1];
}

Class meta::external::dataquality::datarecon::DataQualityReconInput
[
  sourceMustEndWithRuntime: $this.source->isEndingWithFromFunction(),
  targetMustEndWithRuntime: $this.target->isEndingWithFromFunction(),
  sourceMustReturnRelation: $this.source->functionReturnType().rawType->toOne()->subTypeOf(Relation),
  targetMustReturnRelation: $this.target->functionReturnType().rawType->toOne()->subTypeOf(Relation)
]
{
  source: LambdaFunction<Any>[1]; //query pointing to source dataset
  target: LambdaFunction<Any>[1]; //query pointing to target dataset
  keys: String[*]; //these must exist on both source and target dataset - can either be primary keys or grouping keys if aggregated hash required. If empty then hash column will be used.
  aggregatedHash: Boolean[1]; //whether aggregated hash should be created based on the keys provided
  colsForHash: String[*]; //which columns you want the hash to be calculated on, these columns must exist on both source and target dataset. If empty then will calculate hash on all columns.
  sourceHashCol: String[0..1]; //if there already exists a column on source that contains the hash that you want to use in recon
  targetHashCol: String[0..1]; //if there already exists a column on target that contains the hash that you want to use in recon
}