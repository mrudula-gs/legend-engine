// Copyright 2026 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::metamodel::relation::*;
import meta::pure::mapping::*;
import meta::external::query::sql::transformation::compile::utils::*;
import meta::pure::functions::meta::*;
import meta::external::dataquality::*;
import meta::external::dataquality::datarecon::*;
import system::imports::*;
import meta::external::dataquality::dataprofile::*;

/*
  This method will:
    1) select only columns required for hash + keys
    2) for each column create new column suffixed with "_source" or "_target" and normalize it based on the data type (e.g. round floats to 2dp)
    3) create hash for row or use hash column if specified
    4) select only hash col and keys
    5) optional group by and create aggregated hash - making sure hashes are sorted before
    6) join 2 datasets using keys
    7) filter where source and target hash are different
*/
function meta::external::dataquality::datarecon::getDataReconLambda(reconInput: DataQualityReconInput[1]): LambdaFunction<Any>[1]
{  
  let baseLambda = $reconInput.source;
  let sourceDataset = prepareDataset($reconInput.source, 'source', $reconInput.keys, $reconInput.aggregatedHash, $reconInput.colsForHash, $reconInput.sourceHashCol);
  let targetDataset = prepareDataset($reconInput.target, 'target', $reconInput.keys, $reconInput.aggregatedHash, $reconInput.colsForHash, $reconInput.targetHashCol);

  //join by keys
  let withJoin = buildJoinExpression($sourceDataset, $targetDataset, JoinKind.FULL, getJoinColumns($reconInput.keys), $reconInput.sourceHashCol, $reconInput.targetHashCol);
  let joinRelType = getRelType($withJoin);

  //filter where hash is different
  let sourceHashCol = if ($reconInput.sourceHashCol->isNotEmpty() && !$reconInput.aggregatedHash, | $reconInput.sourceHashCol->toOne() + '_SOURCE', | 'DIGEST_SOURCE');
  let targetHashCol = if ($reconInput.targetHashCol->isNotEmpty() && !$reconInput.aggregatedHash, | $reconInput.targetHashCol->toOne() + '_TARGET', | 'DIGEST_TARGET');
  let filterCondition = negatedFunctionExpression(buildComparisonExpression(equal_Any_MANY__Any_MANY__Boolean_1_, 'row', $joinRelType, $sourceHashCol, 'row', $joinRelType, $targetHashCol, ^GenericType(rawType=String)));
  let withFilter = buildFilterExpression($withJoin, $joinRelType, $filterCondition);

  ^$baseLambda(expressionSequence=$withFilter);
}

function meta::external::dataquality::datarecon::prepareDataset(dataset: LambdaFunction<Any>[1], type: String[1], keys: String[*], aggregatedHash: Boolean[1], colsForHash: String[*], hashCol: String[0..1]): ValueSpecification[1]
{  
  validateColumns($dataset, $type, $keys, $colsForHash, $hashCol);
  //need to remove from and add back after compileViaGrammar as runtime not yet supported in compileViaGrammar flow - once fixed we can remove this code
  let from = $dataset.expressionSequence->evaluateAndDeactivate()->last()->cast(@SimpleFunctionExpression)->toOne();
  let input = $dataset->popTerminalFunctionExpression().expressionSequence->evaluateAndDeactivate()->last()->toOne();
  let suffix = '_' + $type->toUpper();
    
  //select relevant columns before normalization
  let colsToSelect = if ($colsForHash->isEmpty() && $hashCol->isEmpty(),
    | [], //if no cols given for hash then we will calculate hash on all columns
    | let colsRequiredForHash = if ($hashCol->isNotEmpty(), | $hashCol, | $colsForHash);
      let selectColsBeforeNormalize = $keys->union($colsRequiredForHash)->distinct();
  );
  let withSelectBeforeNormalize = if ($colsToSelect->isEmpty(), | $input, | buildSelectExpression($input, $colsToSelect));
  
  //normalize cols  
  let withNormalizedCols = normalizeColumns($withSelectBeforeNormalize, getRelType($input), $colsToSelect, $suffix);

  //create hash
  let withHash = if ($hashCol->isNotEmpty(), 
    | $withNormalizedCols,
    | let withRowHash = buildRowHash($withNormalizedCols, $suffix, $type);
      //select only hash col + keys
      let selectCols = $keys->map(col | $col + $suffix)->union('DIGEST' + $suffix)->distinct();
      let withSelect = buildSelectExpression($withRowHash, $selectCols);
  );

  //create aggregated hash
  let hashColumn = if ($hashCol->isNotEmpty(), | $hashCol->toOne(), | 'DIGEST') + $suffix;
  let withAggregatedHash = if ($aggregatedHash,
    | buildAggregatedHash($withHash, getRelType($withHash->compileViaGrammar()), $hashColumn, $keys->map(col | $col + $suffix), $suffix, $type),
    | $withHash
  );

  let compiled = $withAggregatedHash->compileViaGrammar();
  sfe($from.func, $compiled.genericType, [], $compiled->concatenate($from.parametersValues->tail()));
}

function meta::external::dataquality::datarecon::validateColumns(dataset: LambdaFunction<Any>[1], type: String[1], keys: String[*], colsForHash: String[*], hashCol: String[0..1]): Boolean[*]
{  
  let relType = getRelType($dataset.expressionSequence->evaluateAndDeactivate()->last()->toOne());
  validateColumnExists($relType, $keys, $type, 'keys');
  validateColumnExists($relType, $colsForHash, $type, 'column to include for generated hash');
  validateColumnExists($relType, $hashCol, $type, 'column with pre-calculated hash');
}

function meta::external::dataquality::datarecon::validateColumnExists(relType: RelationType<Any>[1], columns: String[*], type: String[1], field: String[1]): Boolean[*]
{
  $columns->map(column | assert($relType.columns->exists(col | $col.name->toOne() == $column), 'Expected ' + $type + ' table to contain field ' + $column + ' which was specified as ' + $field));
}

function meta::external::dataquality::datarecon::normalizeColumns(input: ValueSpecification[1], relType: RelationType<Any>[1], colsToNormalize: String[*], suffix: String[1]):ValueSpecification[1]
{
  let columns = $relType.columns->filter(col | $colsToNormalize->isEmpty() || $colsToNormalize->contains($col.name->toOne()));
  let funcColSpecs = $columns->map(col |
    let colName = $col.name->toOne() + $suffix;
    let colGenericType = $col.classifierGenericType.typeArguments->at(1)->toOne();
    let type = $colGenericType.rawType->toOne();
    let withNormalize = buildNormalizeExpression(col($col, var('row')), $type);
    ^FuncColSpec<Any, Any>(
      name = $colName,
      function=lambda(^FunctionType(returnMultiplicity=PureOne, returnType=^GenericType(rawType=$type), parameters=var('row')), $withNormalize)
    );
  );

  let withNormalized = sfe(
    extend_Relation_1__FuncColSpecArray_1__Relation_1_,
    [ $input, ^FuncColSpecArray<Any, Any>(funcSpecs = $funcColSpecs)->iv()]
  );

  //select only normalized columns
  let withSelect = buildSelectExpression($withNormalized, $columns.name->map(col | $col + $suffix));
}

function meta::external::dataquality::datarecon::buildAggregatedHash(input: ValueSpecification[1], relType: RelationType<Any>[1], hashColumn: String[1], groupingCols: String[*], suffix: String[1], type: String[1]):ValueSpecification[1]
{
  //sort by hash column to ensure aggregated hash created in determinstic manner. 
  //TODO- the correct order by is not used in the generated SQL, we need the order by to be within the group in the aggregation to ensure consistency across different sql engines
  let sortingCol = buildColSpecExpression($hashColumn);
  let sortingInfo = buildSortingInfoExpression(SortType.ASC, $sortingCol);
  let sort = buildSortExpression($input, $sortingInfo);

  //group by grouping keys and aggregate all hashes into single string
  let groupingFunction = buildAggColSpecJoinStringsExpression($relType, $hashColumn, ^GenericType(rawType=String));
  let groupBy = buildGroupByExpression($sort, buildColSpecArrayExpression($groupingCols), $groupingFunction);

  //calculate hash of hashes
  let aggHash = buildRowHash($groupBy, $suffix, $type);

  //select only grouping cols and hash col
  let selectCols = $groupingCols->union('DIGEST' + $suffix);
  buildSelectExpression($aggHash, $selectCols);
}

function meta::external::dataquality::datarecon::buildAggColSpecJoinStringsExpression(relType: RelationType<Any>[1], aggCol: String[1], aggColType: GenericType[1]):ValueSpecification[1]
{
  let map = lambda(^FunctionType(returnMultiplicity = PureOne, returnType = ^GenericType(rawType = String), parameters = var('x')), buildGetValueAtColumnFunctionExpression($relType, $aggCol, 'x', $aggColType));
  let joinStringsExpression = sfe(joinStrings_String_MANY__String_1__String_1_, [var('y'), iv('')]);
  let reduce = lambda(^FunctionType(returnMultiplicity = PureOne, returnType = ^GenericType(rawType = String), parameters = var('y')), $joinStringsExpression);
  
  ^AggColSpec<Any, Any, Any>(
    name = 'AGG_HASH',
    map = $map,
    reduce = $reduce
  )->iv();
}

function meta::external::dataquality::datarecon::buildExtendExpression(input: ValueSpecification[1], colName: String[1], colType: Type[1], newColumnFunction: ValueSpecification[1]):ValueSpecification[1]
{
  sfe(
    extend_Relation_1__FuncColSpec_1__Relation_1_,
    [  
      $input,
      ^FuncColSpec<Any, Any>(
        name = $colName,
        function=lambda(^FunctionType(returnMultiplicity=PureOne, returnType=^GenericType(rawType=$colType), parameters=var('row')), $newColumnFunction)
      )->iv()
    ]
  );
}

function meta::external::dataquality::datarecon::buildRowHash(input: ValueSpecification[1], suffix: String[1], type: String[1]):ValueSpecification[1]
{
  let relType = getRelType($input->compileViaGrammar());
  $input->buildExtendExpression('DIGEST' + $suffix, String, buildHashFunctionExpression($relType, $relType.columns.name->sort(), 'row'));
}

function meta::external::dataquality::datarecon::buildColSpecArrayExpression(selectedCols: String[*]):ValueSpecification[1]
{
  ^ColSpecArray<Any>(names = $selectedCols)->iv();
}

function meta::external::dataquality::datarecon::buildGroupByExpression(input:ValueSpecification[1], groupingColSpec: ValueSpecification[1], groupingFunction: ValueSpecification[1]):SimpleFunctionExpression[1]
{
  sfe(
    groupBy_Relation_1__ColSpecArray_1__AggColSpec_1__Relation_1_,
    [ $input, $groupingColSpec, $groupingFunction ]
  );
}

function meta::external::dataquality::datarecon::buildSelectExpression(input: ValueSpecification[1], selectedCols: String[*]):FunctionExpression[1]
{
  sfe(
    select_Relation_1__ColSpecArray_1__Relation_1_,
    [ $input, buildColSpecArrayExpression($selectedCols)]
  );
}

function meta::external::dataquality::datarecon::buildJoinFunction(joinFields: String[*], sourceHashCol: String[0..1], targetHashCol: String[0..1], relTypeParam1: RelationType<Any>[1], relTypeParam2: RelationType<Any>[1]):InstanceValue[1]
{
  let rel1 = ^VariableExpression(name = 'x', genericType = ^GenericType(rawType = $relTypeParam1), multiplicity = PureOne);
  let rel2 = ^VariableExpression(name = 'y', genericType = ^GenericType(rawType = $relTypeParam2), multiplicity = PureOne);
  let joinCondition = $joinFields->map(field | 
    let sourceCol = if ($field == 'DIGEST' && $sourceHashCol->isNotEmpty(), | $sourceHashCol->toOne(), | $field) + '_SOURCE';
    let targetCol = if ($field == 'DIGEST' && $targetHashCol->isNotEmpty(), | $targetHashCol->toOne(), | $field) + '_TARGET';
    buildComparisonExpression(equal_Any_MANY__Any_MANY__Boolean_1_, 'x', $relTypeParam1, $sourceCol, 'y', $relTypeParam2, $targetCol, getColGenericType($relTypeParam1, $sourceCol));
  );
  let andCondition = $joinCondition->tail()->fold({val1, val2 | buildAndExpression($val1->evaluateAndDeactivate(), $val2->evaluateAndDeactivate())}, $joinCondition->head()->toOne()->evaluateAndDeactivate());

  ^InstanceValue(
      genericType = ^GenericType(rawType = LambdaFunction, typeArguments = ^GenericType(rawType = ^FunctionType(parameters = [$rel1, $rel2], returnMultiplicity = PureOne, returnType = ^GenericType(rawType = Boolean)))),
      multiplicity = PureOne,
      values = lambda(^FunctionType(returnMultiplicity = PureOne, returnType = ^GenericType(rawType = Boolean), parameters = [$rel1, $rel2]), $andCondition)
  )->evaluateAndDeactivate();
}

function meta::external::dataquality::datarecon::buildJoinExpression(param1: ValueSpecification[1], param2: ValueSpecification[1], joinKind: JoinKind[1], joinFields: String[*], sourceHashCol: String[0..1], targetHashCol: String[0..1]): FunctionExpression[1]
{
  let sourceRelType = getRelType($param1);
  let targetRelType = getRelType($param2);
  let relType = getCombinedRelType($sourceRelType, $targetRelType);
  let joinKindExpression = buildJoinKindExpression($joinKind);
  let joinFunction = buildJoinFunction($joinFields, $sourceHashCol, $targetHashCol, $sourceRelType, $targetRelType);
  ^SimpleFunctionExpression
  (
    func = join_Relation_1__Relation_1__JoinKind_1__Function_1__Relation_1_,
    multiplicity = ZeroOne,
    genericType  = ^GenericType(rawType=Relation, typeArguments = ^GenericType(rawType=$relType)),
    importGroup  = coreImport,
    parametersValues =
    [
     $param1,
     $param2,
     $joinKindExpression,
     $joinFunction
    ]
  )->evaluateAndDeactivate();
}

function meta::external::dataquality::datarecon::buildJoinKindExpression(joinKind: JoinKind[1]): FunctionExpression[1]
{
  ^SimpleFunctionExpression
  (
    func = extractEnumValue_Enumeration_1__String_1__T_1_,
    multiplicity = ZeroOne,
    genericType  = ^GenericType(rawType=JoinKind),
    importGroup  = coreImport,
    parametersValues =
    [
      ^InstanceValue(values=JoinKind, genericType=^GenericType(rawType=Enumeration, typeArguments=^GenericType(rawType=JoinKind)), multiplicity=PureOne),
      ^InstanceValue(values=$joinKind->toString(), genericType=^GenericType(rawType=String), multiplicity=PureOne)
    ]
  )->evaluateAndDeactivate();
}

function meta::external::dataquality::datarecon::buildSortExpression(input: ValueSpecification[1], sortingInfo: FunctionExpression[1]):SimpleFunctionExpression[1]
{
  sfe(
    sort_Relation_1__SortInfo_MANY__Relation_1_,
    [$input, $sortingInfo]
  );
}

function meta::external::dataquality::datarecon::buildSortingInfoExpression(sortType: SortType[1], colSpecToSort: ValueSpecification[1]):SimpleFunctionExpression[1]
{
  sfe(
    if ($sortType == SortType.ASC, | ascending_ColSpec_1__SortInfo_1_, | descending_ColSpec_1__SortInfo_1_),
    $colSpecToSort
  );
}

function meta::external::dataquality::datarecon::buildColSpecExpression(colName: String[1]):ValueSpecification[1]
{
  ^ColSpec<Any>(name = $colName)->iv();
}

function meta::external::dataquality::datarecon::buildFilterExpression(input:ValueSpecification[1], relationType:RelationType<Any>[1], comparisonExpression: ValueSpecification[1]):SimpleFunctionExpression[1]
{
    ^SimpleFunctionExpression
   (
      func = filter_Relation_1__Function_1__Relation_1_,
      multiplicity = PureOne,
      genericType  = ^GenericType(rawType=Relation, typeArguments = ^GenericType(rawType=$relationType)),
      importGroup  = coreImport,
      parametersValues =
      [  $input,
         ^InstanceValue (
            genericType = ^GenericType(rawType=LambdaFunction, typeArguments=^GenericType(rawType=^FunctionType(parameters=^VariableExpression(name='row', genericType=^GenericType(rawType=$relationType), multiplicity=PureOne), returnMultiplicity=PureOne, returnType=^GenericType(rawType=Boolean)))),
            multiplicity = PureOne,
            values = lambda(
                      ^FunctionType(returnMultiplicity= PureOne, returnType = ^GenericType(rawType = Boolean), parameters = ^VariableExpression(name='row', genericType=^GenericType(rawType=$relationType), multiplicity=PureOne)),
                      $comparisonExpression
                    )
         )->evaluateAndDeactivate()
      ]
   )->evaluateAndDeactivate();
}

function meta::external::dataquality::datarecon::buildComparisonExpression(func: Function<Any>[1], param1Name: String[1], relTypeParam1:RelationType<Any>[1], colNameParam1: String[1], param2Name: String[1], relTypeParam2:RelationType<Any>[1], colNameParam2: String[1], colType: GenericType[1]):SimpleFunctionExpression[1]
{
  ^SimpleFunctionExpression
  (
    func = $func,
    multiplicity = PureOne,
    genericType  = ^GenericType(rawType=Boolean),
    importGroup  = coreImport,
    parametersValues = [
      buildGetValueAtColumnFunctionExpression($relTypeParam1, $colNameParam1, $param1Name, $colType),
      buildGetValueAtColumnFunctionExpression($relTypeParam2, $colNameParam2, $param2Name, $colType)
    ]
  )->evaluateAndDeactivate()
}

function meta::external::dataquality::datarecon::buildAndExpression(param1: FunctionExpression[1], param2: FunctionExpression[1]):SimpleFunctionExpression[1]
{
  ^SimpleFunctionExpression
  (
    func = and_Boolean_1__Boolean_1__Boolean_1_,
    multiplicity = PureOne,
    genericType  = ^GenericType(rawType=Boolean),
    importGroup  = coreImport,
    parametersValues = [
      $param1,
      $param2
    ]
  )->evaluateAndDeactivate()
}

function meta::external::dataquality::datarecon::buildNormalizeExpression(input: ValueSpecification[1], type: Type[1]):ValueSpecification[1]
{
  let func = if ([
      pair(| $type->subTypeOf(Decimal), | normalizeDecimal_Decimal_1__Decimal_1_),
      pair(| $type->subTypeOf(Float), | normalizeFloat_Float_1__Float_1_),
      pair(| $type->subTypeOf(DateTime), | normalizeDateTime_DateTime_1__DateTime_1_)
    ],
    | []
  );

  if ($func->isEmpty(), 
    | $input,
    | sfe($func->toOne(),$input)
  );
}

function meta::external::dataquality::datarecon::getRelTypeWithNormalizedCol(relType: RelationType<Any>[1], col: Column<Nil,Any|*>[1], normalizedColName: String[1], normalizeExpression: ValueSpecification[1]): RelationType<Any>[1]
{
  let existingColType = $col.classifierGenericType->toOne();
  let normalizedColType = ^$existingColType(typeArguments=[$existingColType.typeArguments->first()->toOne(), $normalizeExpression.genericType]);
  ^RelationType<Nil>(columns = $relType.columns->union(^$col(name=$normalizedColName, classifierGenericType=$normalizedColType)));
}

function meta::external::dataquality::datarecon::getJoinColumns(keys: String[*]): String[*]
{ 
  if ($keys->isNotEmpty(), 
    | $keys, 
    | 'DIGEST'
  );
}

function meta::external::dataquality::datarecon::getColGenericType(relType: RelationType<Any>[1], column: String[1]):GenericType[1]
{
  $relType.columns->filter(x|$x.name == $column)->toOne().classifierGenericType.typeArguments->at(1);
}

function meta::external::dataquality::datarecon::getRelType(input: ValueSpecification[1]): RelationType<Any>[1]
{  
  $input.genericType.typeArguments.rawType->toOne()->cast(@RelationType<Any>);
}
  
function meta::external::dataquality::datarecon::createReconInput(source: LambdaFunction<Any>[1], target: LambdaFunction<Any>[1], keys: String[*], aggregatedHash: Boolean[1], colsForHash: String[*], sourceHashCol: String[0..1], targetHashCol: String[0..1]): DataQualityReconInput[1]
{
  ^DataQualityReconInput(source = $source, target = $target, keys = $keys, aggregatedHash = $aggregatedHash, colsForHash = $colsForHash, sourceHashCol = $sourceHashCol, targetHashCol = $targetHashCol);
}